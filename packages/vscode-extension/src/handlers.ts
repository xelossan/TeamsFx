// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

"use strict";

import {
  commands,
  debug,
  env,
  ExtensionContext,
  QuickPickItem,
  Uri,
  window,
  workspace,
} from "vscode";
import * as fs from "fs-extra";
import * as path from "path";
import * as util from "util";
import * as uuid from "uuid";
import * as vscode from "vscode";

import {
  AppPackageFolderName,
  assembleError,
  AutoGeneratedReadme,
  AzureSolutionSettings,
  BuildFolderName,
  ConcurrentError,
  ConfigFolderName,
  CoreCallbackEvent,
  EnvConfigFileNameTemplate,
  EnvNamePlaceholder,
  EnvStateFileNameTemplate,
  err,
  Func,
  FxError,
  InputConfigsFolderName,
  Inputs,
  IProgressHandler,
  M365TokenProvider,
  ok,
  OptionItem,
  Platform,
  ProjectSettingsFileName,
  Result,
  SelectFileConfig,
  SelectFolderConfig,
  SingleSelectConfig,
  Stage,
  StatesFolderName,
  SubscriptionInfo,
  SystemError,
  TemplateFolderName,
  Tools,
  UserCancelError,
  UserError,
  Void,
  VsCodeEnv,
} from "@microsoft/teamsfx-api";
import { AddSsoParameters } from "@microsoft/teamsfx-core/build/plugins/solution/fx-solution/constants";
import {
  askSubscription,
  AppStudioScopes,
  getAppDirectory,
  getFixedCommonProjectSettings,
  getHashedEnv,
  isExistingTabAppEnabled,
  isUserCancelError,
} from "@microsoft/teamsfx-core/build/common/tools";
import { CollaborationState } from "@microsoft/teamsfx-core/build/common/permissionInterface";
import { Correlator } from "@microsoft/teamsfx-core/build/common/correlator";
import { DepsManager, DepsType } from "@microsoft/teamsfx-core/build/common/deps-checker";
import { environmentManager } from "@microsoft/teamsfx-core/build/core/environment";
import { FolderName } from "@microsoft/teamsfx-core/build/common/local";
import { isValidProject } from "@microsoft/teamsfx-core/build/common/projectSettingsHelper";
import { LocalEnvManager, ProjectSettingsHelper } from "@microsoft/teamsfx-core/build/common/local";
import {
  globalStateUpdate,
  globalStateGet,
} from "@microsoft/teamsfx-core/build/common/globalState";
import { UserTaskFunctionName } from "@microsoft/teamsfx-core/build/plugins/solution/fx-solution/constants";
import { FxCore } from "@microsoft/teamsfx-core";
import { InvalidProjectError } from "@microsoft/teamsfx-core/build/core/error";

import M365TokenInstance from "./commonlib/m365Login";
import AzureAccountManager from "./commonlib/azureLogin";
import { signedIn, signedOut } from "./commonlib/common/constant";
import VsCodeLogInstance from "./commonlib/log";
import {
  AadManifestDeployConstants,
  AzureAssignRoleHelpUrl,
  AzurePortalUrl,
  CLI_FOR_M365,
  GlobalKey,
  SpfxManageSiteAdminUrl,
  SUPPORTED_SPFX_PRERELEASE_VERSION,
  SUPPORTED_SPFX_VERSION,
} from "./constants";
import { PanelType } from "./controls/PanelType";
import { WebviewPanel } from "./controls/webviewPanel";
import * as commonUtils from "./debug/commonUtils";
import * as constants from "./debug/constants";
import { installBackendExtension } from "./debug/depsChecker/backendExtensionsInstall";
import { VSCodeDepsChecker } from "./debug/depsChecker/vscodeChecker";
import { vscodeHelper } from "./debug/depsChecker/vscodeHelper";
import { vscodeLogger } from "./debug/depsChecker/vscodeLogger";
import { vscodeTelemetry } from "./debug/depsChecker/vscodeTelemetry";
import { openHubWebClient } from "./debug/launch";
import { automaticNpmInstallHandler } from "./debug/npmInstallHandler";
import * as localPrerequisites from "./debug/prerequisitesHandler";
import { selectAndDebug } from "./debug/runIconHandler";
import { getTeamsAppInternalId, showInstallAppInTeamsMessage } from "./debug/teamsAppInstallation";
import { terminateAllRunningTeamsfxTasks } from "./debug/teamsfxTaskHandler";
import { ExtensionErrors, ExtensionSource } from "./error";
import * as exp from "./exp/index";
import { VS_CODE_UI } from "./extension";
import * as globalVariables from "./globalVariables";
import { TeamsAppMigrationHandler } from "./migration/migrationHandler";
import { ExtTelemetry } from "./telemetry/extTelemetry";
import {
  AccountType,
  TelemetryEvent,
  TelemetryProperty,
  TelemetrySuccess,
  TelemetryTriggerFrom,
  TelemetryUpdateAppReason,
  VSCodeWindowChoice,
} from "./telemetry/extTelemetryEvents";
import accountTreeViewProviderInstance from "./treeview/account/accountTreeViewProvider";
import { AzureAccountNode } from "./treeview/account/azureNode";
import { AccountItemStatus } from "./treeview/account/common";
import { M365AccountNode } from "./treeview/account/m365Node";
import envTreeProviderInstance from "./treeview/environmentTreeViewProvider";
import { TreeViewCommand } from "./treeview/treeViewCommand";
import TreeViewManagerInstance from "./treeview/treeViewManager";
import { CommandsWebviewProvider } from "./treeview/webViewProvider/commandsWebviewProvider";
import {
  anonymizeFilePaths,
  getAppName,
  getM365TenantFromEnv,
  getProjectId,
  getProvisionSucceedFromEnv,
  getResourceGroupNameFromEnv,
  getSubscriptionInfoFromEnv,
  getTeamsAppTelemetryInfoByEnv,
  getTriggerFromProperty,
  isExistingTabApp,
  isTriggerFromWalkThrough,
  openFolderInExplorer,
} from "./utils/commonUtils";
import { localize, parseLocale } from "./utils/localizeUtils";
import {
  localTelemetryReporter,
  sendDebugAllEvent,
  sendDebugAllStartEvent,
} from "./debug/localTelemetryReporter";
import { compare } from "./utils/versionUtil";
import { getSPFxVersion } from "@microsoft/teamsfx-core/build/common/tools";

export let core: FxCore;
export let tools: Tools;

export function activate(): Result<Void, FxError> {
  const result: Result<Void, FxError> = ok(Void);
  const validProject = isValidProject(globalVariables.workspaceUri?.fsPath);
  if (validProject) {
    const fixedProjectSettings = getFixedCommonProjectSettings(
      globalVariables.workspaceUri?.fsPath
    );
    ExtTelemetry.addSharedProperty(TelemetryProperty.ProjectId, fixedProjectSettings?.projectId);
    ExtTelemetry.addSharedProperty(
      TelemetryProperty.IsFromSample,
      fixedProjectSettings?.isFromSample
    );
    ExtTelemetry.addSharedProperty(
      TelemetryProperty.ProgrammingLanguage,
      fixedProjectSettings?.programmingLanguage
    );
    ExtTelemetry.addSharedProperty(TelemetryProperty.HostType, fixedProjectSettings?.hostType);
    ExtTelemetry.addSharedProperty(TelemetryProperty.IsM365, fixedProjectSettings?.isM365);

    ExtTelemetry.sendTelemetryEvent(TelemetryEvent.OpenTeamsApp, {});
    AzureAccountManager.setStatusChangeMap(
      "successfully-sign-in-azure",
      (status, token, accountInfo) => {
        if (status === signedIn) {
          window.showInformationMessage(localize("teamstoolkit.handlers.azureSignIn"));
        } else if (status === signedOut) {
          window.showInformationMessage(localize("teamstoolkit.handlers.azureSignOut"));
        }
        return Promise.resolve();
      },
      false
    );
  }
  try {
    const m365Login: M365TokenProvider = M365TokenInstance;
    const m365NotificationCallback = (
      status: string,
      token: string | undefined,
      accountInfo: Record<string, unknown> | undefined
    ) => {
      if (status === signedIn) {
        window.showInformationMessage(localize("teamstoolkit.handlers.m365SignIn"));
      } else if (status === signedOut) {
        window.showInformationMessage(localize("teamstoolkit.handlers.m365SignOut"));
      }
      return Promise.resolve();
    };

    M365TokenInstance.setStatusChangeMap(
      "successfully-sign-in-m365",
      { scopes: AppStudioScopes },
      m365NotificationCallback,
      false
    );
    tools = {
      logProvider: VsCodeLogInstance,
      tokenProvider: {
        azureAccountProvider: AzureAccountManager,
        m365TokenProvider: m365Login,
      },
      telemetryReporter: ExtTelemetry.reporter,
      treeProvider: TreeViewManagerInstance.getTreeView("teamsfx-accounts")!,
      ui: VS_CODE_UI,
      expServiceProvider: exp.getExpService(),
    };
    core = new FxCore(tools);
    const workspacePath = globalVariables.workspaceUri?.fsPath;
    if (workspacePath) {
      const unifyConfigWatcher = vscode.workspace.createFileSystemWatcher(
        "**/unify-config-and-aad-manifest-change-logs.md"
      );

      unifyConfigWatcher.onDidCreate(async (event) => {
        await openUnifyConfigMd(workspacePath, event.fsPath);
      });

      const backupConfigWatcher = vscode.workspace.createFileSystemWatcher(
        "**/backup-config-change-logs.md"
      );

      backupConfigWatcher.onDidCreate(async (event) => {
        await openBackupConfigMd(workspacePath, event.fsPath);
      });
    }
    automaticNpmInstallHandler(false, false, false);

    if (workspacePath) {
      // refresh env tree when env config files added or deleted.
      workspace.onDidCreateFiles(async (event) => {
        await refreshEnvTreeOnFileChanged(workspacePath, event.files);
      });

      workspace.onDidDeleteFiles(async (event) => {
        await refreshEnvTreeOnFileChanged(workspacePath, event.files);
      });

      workspace.onDidRenameFiles(async (event) => {
        const files = [];
        for (const f of event.files) {
          files.push(f.newUri);
          files.push(f.oldUri);
        }

        await refreshEnvTreeOnFileChanged(workspacePath, files);
      });

      workspace.onDidSaveTextDocument(async (event) => {
        await refreshEnvTreeOnFileContentChanged(workspacePath, event.uri.fsPath);
      });
    }
  } catch (e) {
    const FxError: FxError = {
      name: e.name,
      source: ExtensionSource,
      message: e.message,
      stack: e.stack,
      timestamp: new Date(),
    };
    showError(FxError);
    return err(FxError);
  }
  return result;
}

export async function getIsFromSample(projectPath?: string) {
  if (core) {
    const input = getSystemInputs();
    input.ignoreEnvInfo = true;

    if (projectPath) {
      input.projectPath = projectPath;
    }

    await core.getProjectConfig(input);

    return core.isFromSample;
  }
  return undefined;
}

export async function getIsM365(): Promise<boolean | undefined> {
  if (core) {
    const input = getSystemInputs();
    input.ignoreEnvInfo = true;
    const res = await core.getProjectConfig(input);

    if (res.isOk()) {
      return res?.value?.settings?.isM365;
    }
  }
  return undefined;
}

// only used for telemetry
export async function getSettingsVersion(): Promise<string | undefined> {
  if (core) {
    const input = getSystemInputs();
    input.ignoreEnvInfo = true;

    // TODO: from the experience of 'is-from-sample':
    // in some circumstances, getProjectConfig() returns undefined even projectSettings.json is valid.
    // This is a workaround to prevent that. We can change to the following code after the root cause is found.
    // const projectConfig = await core.getProjectConfig(input);
    // ignore errors for telemetry
    // if (projectConfig.isOk()) {
    //   return projectConfig.value?.settings?.version;
    // }
    await core.getProjectConfig(input);
    return core.settingsVersion;
  }
  return undefined;
}

async function refreshEnvTreeOnFileChanged(workspacePath: string, files: readonly Uri[]) {
  let needRefresh = false;
  for (const file of files) {
    // check if file is env config
    if (environmentManager.isEnvConfig(workspacePath, file.fsPath)) {
      needRefresh = true;
      break;
    }
  }

  if (needRefresh) {
    await envTreeProviderInstance.reloadEnvironments();
  }
}

async function openUnifyConfigMd(workspacePath: string, filePath: string) {
  const backupName = ".backup";
  const unifyConfigMD = "unify-config-and-aad-manifest-change-logs.md";
  const changeLogsPath: string = path.join(workspacePath, backupName, unifyConfigMD);
  if (changeLogsPath !== filePath) {
    return;
  }
  const uri = Uri.file(changeLogsPath);

  workspace.openTextDocument(uri).then(() => {
    const PreviewMarkdownCommand = "markdown.showPreview";
    commands.executeCommand(PreviewMarkdownCommand, uri);
  });
}

async function openBackupConfigMd(workspacePath: string, filePath: string) {
  const backupName = ".backup";
  const unifyConfigMD = "backup-config-change-logs.md";
  const changeLogsPath: string = path.join(workspacePath, backupName, unifyConfigMD);
  if (changeLogsPath !== filePath) {
    return;
  }
  const uri = Uri.file(changeLogsPath);

  workspace.openTextDocument(uri).then(() => {
    const PreviewMarkdownCommand = "markdown.showPreview";
    commands.executeCommand(PreviewMarkdownCommand, uri);
  });
}

async function refreshEnvTreeOnFileContentChanged(workspacePath: string, filePath: string) {
  const projectSettingsPath = path.resolve(
    workspacePath,
    `.${ConfigFolderName}`,
    InputConfigsFolderName,
    ProjectSettingsFileName
  );

  // check if file is project config
  if (path.normalize(filePath) === path.normalize(projectSettingsPath)) {
    await envTreeProviderInstance.reloadEnvironments();
  }
}

function registerCoreEvents() {
  // legacy codes for webview provider
  const developmentView = TreeViewManagerInstance.getTreeView("teamsfx-development");
  if (developmentView instanceof CommandsWebviewProvider) {
    core.on(CoreCallbackEvent.lock, () => {
      (
        TreeViewManagerInstance.getTreeView("teamsfx-development") as CommandsWebviewProvider
      ).onLockChanged(true);
    });
    core.on(CoreCallbackEvent.unlock, () => {
      (
        TreeViewManagerInstance.getTreeView("teamsfx-development") as CommandsWebviewProvider
      ).onLockChanged(false);
    });
  }

  const deploymentView = TreeViewManagerInstance.getTreeView("teamsfx-deployment");
  if (deploymentView instanceof CommandsWebviewProvider) {
    core.on(CoreCallbackEvent.lock, () => {
      (
        TreeViewManagerInstance.getTreeView("teamsfx-deployment") as CommandsWebviewProvider
      ).onLockChanged(true);
    });
    core.on(CoreCallbackEvent.unlock, () => {
      (
        TreeViewManagerInstance.getTreeView("teamsfx-deployment") as CommandsWebviewProvider
      ).onLockChanged(false);
    });
  }
}

export async function getAzureSolutionSettings(): Promise<AzureSolutionSettings | undefined> {
  const input = getSystemInputs();
  input.ignoreEnvInfo = true;
  const projectConfigRes = await core.getProjectConfig(input);

  if (projectConfigRes?.isOk()) {
    if (projectConfigRes.value) {
      return projectConfigRes.value.settings?.solutionSettings as AzureSolutionSettings;
    }
  }
  // else {
  //   showError(projectConfigRes.error);
  // }
  return undefined;
}

export function getSystemInputs(): Inputs {
  const answers: Inputs = {
    projectPath: globalVariables.workspaceUri?.fsPath,
    platform: Platform.VSCode,
    vscodeEnv: detectVsCodeEnv(),
    "function-dotnet-checker-enabled": vscodeHelper.isDotnetCheckerEnabled(),
    locale: parseLocale(),
  };
  return answers;
}

export async function createNewProjectHandler(args?: any[]): Promise<Result<any, FxError>> {
  ExtTelemetry.sendTelemetryEvent(TelemetryEvent.CreateProjectStart, getTriggerFromProperty(args));
  const result = await runCommand(Stage.create);
  if (result.isErr()) {
    return err(result.error);
  }

  const projectPathUri = result.value as Uri;
  if (await isExistingTabApp(projectPathUri.fsPath)) {
    // show local preview button for existing tab app
    await openFolder(projectPathUri, false, true, args);
  } else {
    // show local debug button by default
    await openFolder(projectPathUri, true, false, args);
  }
  return result;
}

export async function initProjectHandler(args?: any[]): Promise<Result<any, FxError>> {
  ExtTelemetry.sendTelemetryEvent(TelemetryEvent.InitProjectStart, getTriggerFromProperty(args));
  const result = await runCommand(Stage.init);
  if (result.isOk()) {
    await openFolder(result.value, false, true, args);
  }
  return result;
}

export async function openFolder(
  folderPath: Uri,
  showLocalDebugMessage: boolean,
  showLocalPreviewMessage: boolean,
  args?: any[]
) {
  await updateAutoOpenGlobalKey(showLocalDebugMessage, showLocalPreviewMessage, folderPath, args);
  ExtTelemetry.sendTelemetryEvent(TelemetryEvent.OpenNewProject, {
    [TelemetryProperty.VscWindow]: VSCodeWindowChoice.NewWindowByDefault,
  });
  commands.executeCommand("vscode.openFolder", folderPath, true);
}

export async function updateAutoOpenGlobalKey(
  showLocalDebugMessage: boolean,
  showLocalPreviewMessage: boolean,
  projectUri: Uri,
  args?: any[]
): Promise<void> {
  const isSample = await getIsFromSample(projectUri.fsPath);
  if (isTriggerFromWalkThrough(args) && !isSample) {
    await globalStateUpdate(GlobalKey.OpenWalkThrough, true);
    await globalStateUpdate(GlobalKey.OpenReadMe, "");
  } else if (isSample) {
    await globalStateUpdate(GlobalKey.OpenWalkThrough, false);
    await globalStateUpdate(GlobalKey.OpenSampleReadMe, true);
  } else {
    await globalStateUpdate(GlobalKey.OpenWalkThrough, false);
    await globalStateUpdate(GlobalKey.OpenReadMe, projectUri.fsPath);
  }

  if (showLocalDebugMessage) {
    await globalStateUpdate(GlobalKey.ShowLocalDebugMessage, true);
  }

  if (showLocalPreviewMessage) {
    await globalStateUpdate(GlobalKey.ShowLocalPreviewMessage, true);
  }
}

export async function createProjectFromWalkthroughHandler(
  args?: any[]
): Promise<Result<any, FxError>> {
  ExtTelemetry.sendTelemetryEvent(TelemetryEvent.CreateProjectStart, getTriggerFromProperty(args));
  const result = await runCommand(Stage.create);
  return result;
}

export async function debugHandler(args?: any[]): Promise<Result<null, FxError>> {
  ExtTelemetry.sendTelemetryEvent(TelemetryEvent.TreeViewLocalDebug, getTriggerFromProperty(args));
  await vscode.commands.executeCommand("workbench.action.debug.start");

  return ok(null);
}

export async function selectAndDebugHandler(args?: any[]): Promise<Result<null, FxError>> {
  ExtTelemetry.sendTelemetryEvent(TelemetryEvent.RunIconDebugStart, getTriggerFromProperty(args));
  const result = await selectAndDebug();
  await processResult(TelemetryEvent.RunIconDebug, result);
  return result;
}

export async function treeViewLocalDebugHandler(args?: any[]): Promise<Result<null, FxError>> {
  ExtTelemetry.sendTelemetryEvent(TelemetryEvent.TreeViewLocalDebug);
  await vscode.commands.executeCommand("workbench.action.quickOpen", "debug ");

  return ok(null);
}

export async function treeViewPreviewHandler(env: string): Promise<Result<null, FxError>> {
  ExtTelemetry.sendTelemetryEvent(TelemetryEvent.TreeViewPreviewStart);
  const LocalEnvName = environmentManager.getLocalEnvName();
  const PreviewLocalSteps = 2;
  const PreviewRemoteSteps = 1;

  const progressBar = VS_CODE_UI.createProgressBar(
    localize("teamstoolkit.preview.progressTitle"),
    env === LocalEnvName ? PreviewLocalSteps : PreviewRemoteSteps
  );
  await progressBar.start();

  let result: Result<null, FxError>;
  if (env === LocalEnvName) {
    result = await previewLocal(progressBar);
  } else {
    result = await previewRemote(env, progressBar);
  }

  if (result.isErr()) {
    ExtTelemetry.sendTelemetryErrorEvent(TelemetryEvent.TreeViewPreview, result.error);
    await progressBar.end(false);
    return result;
  }

  ExtTelemetry.sendTelemetryEvent(TelemetryEvent.TreeViewPreview, {
    [TelemetryProperty.Success]: TelemetrySuccess.Yes,
  });
  await progressBar.end(true);
  return ok(null);
}

async function previewLocal(progressBar: IProgressHandler): Promise<Result<null, FxError>> {
  await progressBar.next(localize("teamstoolkit.preview.prepareTeamsApp"));

  const result = await runCommand(Stage.debug);
  if (result.isErr()) {
    return result;
  }

  const debugConfig = await commonUtils.getDebugConfig(true);
  if (!debugConfig?.appId) {
    const error = new UserError(
      ExtensionSource,
      ExtensionErrors.TeamsAppIdNotFoundError,
      util.format(
        localize("teamstoolkit.handlers.teamsAppIdNotFound"),
        environmentManager.getLocalEnvName()
      )
    );
    return err(error);
  }
  await progressBar.next(localize("teamstoolkit.preview.launchTeamsApp"));
  await openHubWebClient(true, debugConfig.appId, constants.Hub.teams);
  return ok(null);
}

async function previewRemote(
  env: string,
  progressBar: IProgressHandler
): Promise<Result<null, FxError>> {
  try {
    const debugConfig = await commonUtils.getDebugConfig(false, env);
    if (!debugConfig?.appId) {
      const error = new UserError(
        ExtensionSource,
        ExtensionErrors.TeamsAppIdNotFoundError,
        util.format(localize("teamstoolkit.handlers.teamsAppIdNotFound"), env)
      );
      return err(error);
    }

    const localEnvManager = new LocalEnvManager(
      VsCodeLogInstance,
      ExtTelemetry.reporter,
      VS_CODE_UI
    );
    const projectSettings = await localEnvManager.getProjectSettings(
      globalVariables.workspaceUri!.fsPath
    );
    const includeFrontend = ProjectSettingsHelper.includeFrontend(projectSettings);

    let hub = constants.Hub.teams;
    if (projectSettings.isM365) {
      const platformSingleSelect: SingleSelectConfig = {
        name: "platform",
        title: localize("teamstoolkit.preview.platform.title"),
        options: [constants.Hub.teams, constants.Hub.outlook],
        placeholder: localize("teamstoolkit.preview.platform.placeholder"),
      };
      if (includeFrontend) {
        (platformSingleSelect.options as string[]).push(constants.Hub.office);
      }
      const platformResult = await VS_CODE_UI.selectOption(platformSingleSelect);
      if (platformResult.isErr()) {
        return err(platformResult.error);
      }

      hub = platformResult.value.result as constants.Hub;
    }

    if (hub === constants.Hub.teams) {
      await progressBar.next(localize("teamstoolkit.preview.launchTeamsApp"));
      await openHubWebClient(includeFrontend, debugConfig.appId, hub);
    } else {
      const shouldContinue = await showInstallAppInTeamsMessage(env, debugConfig.appId);
      if (!shouldContinue) {
        return err(UserCancelError);
      }

      const internalId = await getTeamsAppInternalId(debugConfig.appId);
      if (internalId !== undefined) {
        await progressBar.next(localize("teamstoolkit.preview.launchTeamsApp"));
        await openHubWebClient(includeFrontend, internalId, hub);
      }
    }
  } catch (error) {
    const assembledError = assembleError(error);
    showError(assembledError);
    return err(assembledError);
  }

  return ok(null);
}

export async function addFeatureHandler(args?: any[]): Promise<Result<null, FxError>> {
  ExtTelemetry.sendTelemetryEvent(TelemetryEvent.AddFeatureStart, getTriggerFromProperty(args));
  const func: Func = {
    namespace: "fx-solution-azure",
    method: "addFeature",
  };
  let excludeFrontend = true,
    excludeBot = true,
    excludeBackend = true;
  try {
    const localEnvManager = new LocalEnvManager(
      VsCodeLogInstance,
      ExtTelemetry.reporter,
      VS_CODE_UI
    );
    const projectSettings = await localEnvManager.getProjectSettings(
      globalVariables.workspaceUri!.fsPath
    );
    excludeFrontend = ProjectSettingsHelper.includeFrontend(projectSettings);
    excludeBackend = ProjectSettingsHelper.includeBackend(projectSettings);
    excludeBot = ProjectSettingsHelper.includeBot(projectSettings);
  } catch (error) {
    VsCodeLogInstance.warning(`${error}`);
  }
  const result = await runUserTask(func, TelemetryEvent.AddFeature, true);
  if (result.isOk()) {
    await globalStateUpdate("automaticNpmInstall", true);
    await automaticNpmInstallHandler(excludeFrontend, excludeBackend, excludeBot);
    await envTreeProviderInstance.reloadEnvironments();

    if (
      workspace.workspaceFolders &&
      workspace.workspaceFolders.length > 0 &&
      result.value?.func == AddSsoParameters.AddSso
    ) {
      const capabilities = result.value.capabilities;

      const workspaceFolder = workspace.workspaceFolders[0];
      const workspacePath: string = workspaceFolder.uri.fsPath;
      const authFolder = await commonUtils.getProjectRoot(workspacePath, "auth");

      for (const capability of capabilities) {
        const uri = Uri.file(`${authFolder}/${capability}/README.md`);
        await workspace.openTextDocument(uri).then(async () => {
          const PreviewMarkdownCommand = "markdown.showPreview";
          await commands.executeCommand(PreviewMarkdownCommand, uri);
          await commands.executeCommand("markdown.preview.toggleLock");
        });
      }
    } else if (result.value?.func === UserTaskFunctionName.ConnectExistingApi) {
      const files: string[] = result.value.generatedFiles;
      for (const generatedFile of files) {
        workspace.openTextDocument(generatedFile).then((document) => {
          window.showTextDocument(document, { preview: false });
        });
      }
    }
  }

  return result;
}

export async function validateManifestHandler(args?: any[]): Promise<Result<null, FxError>> {
  ExtTelemetry.sendTelemetryEvent(
    TelemetryEvent.ValidateManifestStart,
    getTriggerFromProperty(args)
  );

  const func: Func = {
    namespace: "fx-solution-azure",
    method: "validateManifest",
    params: {},
  };

  const selectedEnv = await askTargetEnvironment();
  if (selectedEnv.isErr()) {
    ExtTelemetry.sendTelemetryErrorEvent(TelemetryEvent.ValidateManifest, selectedEnv.error);
    showError(selectedEnv.error);
    return err(selectedEnv.error);
  }
  const env = selectedEnv.value;

  const isLocalDebug = env === environmentManager.getLocalEnvName();
  if (isLocalDebug) {
    func.params.type = "localDebug";
    return await runUserTask(func, TelemetryEvent.ValidateManifest, false, env);
  } else {
    func.params.type = "remote";
    return await runUserTask(func, TelemetryEvent.ValidateManifest, false, env);
  }
}

/**
 * Ask user to select environment, local is included
 */
async function askTargetEnvironment(): Promise<Result<string, FxError>> {
  const projectPath = globalVariables.workspaceUri?.fsPath;
  if (!isValidProject(projectPath)) {
    return err(new InvalidProjectError());
  }
  const envProfilesResult = await environmentManager.listRemoteEnvConfigs(projectPath!);
  if (envProfilesResult.isErr()) {
    return err(envProfilesResult.error);
  }
  const config: SingleSelectConfig = {
    name: "targetEnvName",
    title: "Select an environment",
    options: envProfilesResult.value.concat(["local"]),
  };
  const selectedEnv = await VS_CODE_UI.selectOption(config);
  if (selectedEnv.isErr()) {
    return err(selectedEnv.error);
  } else {
    return ok(selectedEnv.value.result as string);
  }
}

export async function buildPackageHandler(args?: any[]): Promise<Result<any, FxError>> {
  ExtTelemetry.sendTelemetryEvent(TelemetryEvent.BuildStart, getTriggerFromProperty(args));

  const func: Func = {
    namespace: "fx-solution-azure",
    method: "buildPackage",
    params: {
      type: "",
    },
  };

  if (args && args.length > 0 && args[0] != TelemetryTriggerFrom.TreeView) {
    func.params.type = args[0];
    const isLocalDebug = args[0] === "localDebug";
    if (isLocalDebug) {
      return await runUserTask(func, TelemetryEvent.Build, false, "local");
    } else {
      return await runUserTask(func, TelemetryEvent.Build, false, args[1]);
    }
  } else {
    const selectedEnv = await askTargetEnvironment();
    if (selectedEnv.isErr()) {
      ExtTelemetry.sendTelemetryErrorEvent(TelemetryEvent.Build, selectedEnv.error);
      showError(selectedEnv.error);
      return err(selectedEnv.error);
    }
    const env = selectedEnv.value;
    const isLocalDebug = env === "local";
    if (isLocalDebug) {
      func.params.type = "localDebug";
      return await runUserTask(func, TelemetryEvent.Build, false, env);
    } else {
      func.params.type = "remote";
      return await runUserTask(func, TelemetryEvent.Build, false, env);
    }
  }
}

export async function provisionHandler(args?: any[]): Promise<Result<null, FxError>> {
  ExtTelemetry.sendTelemetryEvent(TelemetryEvent.ProvisionStart, getTriggerFromProperty(args));
  const result = await runCommand(Stage.provision);

  if (result.isErr() && isUserCancelError(result.error)) {
    return result;
  } else {
    // refresh env tree except provision cancelled.
    await envTreeProviderInstance.reloadEnvironments();
    return result;
  }
}

export async function deployHandler(args?: any[]): Promise<Result<null, FxError>> {
  ExtTelemetry.sendTelemetryEvent(TelemetryEvent.DeployStart, getTriggerFromProperty(args));
  return await runCommand(Stage.deploy);
}

export async function publishHandler(args?: any[]): Promise<Result<null, FxError>> {
  ExtTelemetry.sendTelemetryEvent(TelemetryEvent.PublishStart, getTriggerFromProperty(args));
  return await runCommand(Stage.publish);
}

export async function showOutputChannel(args?: any[]): Promise<Result<any, FxError>> {
  ExtTelemetry.sendTelemetryEvent(TelemetryEvent.ShowOutputChannel);
  VsCodeLogInstance.outputChannel.show();
  return ok(null);
}

export async function openFolderHandler(args?: any[]): Promise<Result<any, FxError>> {
  const scheme = "file://";
  ExtTelemetry.sendTelemetryEvent(TelemetryEvent.OpenFolder, {
    [TelemetryProperty.TriggerFrom]: TelemetryTriggerFrom.Notification,
  });
  if (args && args.length > 0 && args[0]) {
    let path = args[0] as string;
    if (path.startsWith(scheme)) {
      path = path.substring(scheme.length);
    }
    const uri = Uri.file(path);
    openFolderInExplorer(uri.fsPath);
  }
  return ok(null);
}

export async function runCommand(
  stage: Stage,
  defaultInputs?: Inputs
): Promise<Result<any, FxError>> {
  const eventName = ExtTelemetry.stageToEvent(stage);
  let result: Result<any, FxError> = ok(null);
  let inputs: Inputs | undefined;
  try {
    const checkCoreRes = checkCoreNotEmpty();
    if (checkCoreRes.isErr()) {
      throw checkCoreRes.error;
    }

    inputs = defaultInputs ? defaultInputs : getSystemInputs();
    inputs.stage = stage;

    switch (stage) {
      case Stage.create: {
        inputs.projectId = inputs.projectId ?? uuid.v4();
        const tmpResult = await core.createProject(inputs);
        if (tmpResult.isErr()) {
          result = err(tmpResult.error);
        } else {
          const uri = Uri.file(tmpResult.value);
          result = ok(uri);
        }
        break;
      }
      case Stage.init: {
        const initResult = await core.init(inputs);
        if (initResult.isErr()) {
          result = err(initResult.error);
        } else {
          const uri = Uri.file(initResult.value);
          result = ok(uri);
        }
        break;
      }
      case Stage.provision: {
        result = await core.provisionResources(inputs);
        break;
      }
      case Stage.deploy: {
        result = await core.deployArtifacts(inputs);
        break;
      }
      case Stage.publish: {
        result = await core.publishApplication(inputs);
        break;
      }
      case Stage.debug: {
        inputs.ignoreEnvInfo = false;
        inputs.checkerInfo = {
          skipNgrok: !vscodeHelper.isNgrokCheckerEnabled(),
          trustDevCert: vscodeHelper.isTrustDevCertEnabled(),
        };
        result = await core.localDebug(inputs);
        break;
      }
      case Stage.createEnv: {
        result = await core.createEnv(inputs);
        break;
      }
      case Stage.listCollaborator: {
        result = await core.listCollaborator(inputs);
        break;
      }
      default:
        throw new SystemError(
          ExtensionSource,
          ExtensionErrors.UnsupportedOperation,
          util.format(localize("teamstoolkit.handlers.operationNotSupport"), stage)
        );
    }
  } catch (e) {
    result = wrapError(e);
  }

  await processResult(eventName, result, inputs);

  return result;
}

export async function downloadSample(inputs: Inputs): Promise<Result<any, FxError>> {
  let result: Result<any, FxError> = ok(null);
  try {
    const checkCoreRes = checkCoreNotEmpty();
    if (checkCoreRes.isErr()) {
      throw checkCoreRes.error;
    }

    inputs.stage = Stage.create;
    inputs["scratch"] = "no";
    const tmpResult = await core.createProject(inputs);
    if (tmpResult.isErr()) {
      result = err(tmpResult.error);
    } else {
      const uri = Uri.file(tmpResult.value);
      result = ok(uri);
    }
  } catch (e) {
    result = wrapError(e);
  }

  if (result.isErr()) {
    const error = result.error;
    if (!isUserCancelError(error)) {
      if (isLoginFailureError(error)) {
        window.showErrorMessage(localize("teamstoolkit.handlers.loginFailed"));
      } else {
        showError(error);
      }
    }
  }

  return result;
}

export function detectVsCodeEnv(): VsCodeEnv {
  // extensionKind returns ExtensionKind.UI when running locally, so use this to detect remote
  const extension = vscode.extensions.getExtension("TeamsDevApp.ms-teams-vscode-extension");

  if (extension?.extensionKind === vscode.ExtensionKind.Workspace) {
    // running remotely
    // Codespaces browser-based editor will return UIKind.Web for uiKind
    if (vscode.env.uiKind === vscode.UIKind.Web) {
      return VsCodeEnv.codespaceBrowser;
    } else if (vscode.env.remoteName === "codespaces") {
      return VsCodeEnv.codespaceVsCode;
    } else {
      return VsCodeEnv.remote;
    }
  } else {
    // running locally
    return VsCodeEnv.local;
  }
}

export async function runUserTask(
  func: Func,
  eventName: string,
  ignoreEnvInfo: boolean,
  envName?: string
): Promise<Result<any, FxError>> {
  let result: Result<any, FxError> = ok(null);
  let inputs: Inputs | undefined;
  try {
    const checkCoreRes = checkCoreNotEmpty();
    if (checkCoreRes.isErr()) {
      throw checkCoreRes.error;
    }

    inputs = getSystemInputs();
    inputs.ignoreEnvInfo = ignoreEnvInfo;
    inputs.env = envName;
    result = await core.executeUserTask(func, inputs);
  } catch (e) {
    result = wrapError(e);
  }

  await processResult(eventName, result, inputs);

  return result;
}

//TODO workaround
function isLoginFailureError(error: FxError): boolean {
  return !!error.message && error.message.includes("Cannot get user login information");
}

function showWarningMessageWithProvisionButton(message: string): void {
  window
    .showWarningMessage(message, localize("teamstoolkit.handlers.provisionResourcesButton"))
    .then((result) => {
      if (result === localize("teamstoolkit.handlers.provisionResourcesButton")) {
        return Correlator.run(provisionHandler);
      }
    });
}

async function showGrantSuccessMessageWithGetHelpButton(
  message: string,
  helpUrl: string
): Promise<void> {
  window
    .showInformationMessage(message, localize("teamstoolkit.handlers.getHelp"))
    .then((result) => {
      if (result === localize("teamstoolkit.handlers.getHelp")) {
        return VS_CODE_UI.openUrl(helpUrl);
      }
    });
}

async function checkCollaborationState(env: string): Promise<Result<any, FxError>> {
  try {
    const provisionSucceeded = await getProvisionSucceedFromEnv(env);
    if (!provisionSucceeded) {
      return ok({
        state: CollaborationState.NotProvisioned,
        message: localize("teamstoolkit.handlers.provisionBeforeGrantOrListPermission"),
      });
    }

    const tokenJsonObjectRes = await M365TokenInstance.getJsonObject({
      scopes: AppStudioScopes,
      showDialog: true,
    });
    const tokenJsonObject = tokenJsonObjectRes.isOk() ? tokenJsonObjectRes.value : undefined;
    if (tokenJsonObject) {
      const m365TenantId = await getM365TenantFromEnv(env);
      if (!m365TenantId) {
        return ok({
          state: CollaborationState.EmptyM365Tenant,
          message: localize("teamstoolkit.commandsTreeViewProvider.emptyM365Tenant"),
        });
      }
      if (tokenJsonObject.tid !== m365TenantId) {
        return ok({
          state: CollaborationState.M365TenantNotMatch,
          message: localize("teamstoolkit.commandsTreeViewProvider.m365TenantNotMatch"),
        });
      }
    } else {
      return ok({
        state: CollaborationState.m365AccountNotSignedIn,
        message: localize("teamstoolkit.commandsTreeViewProvider.m365AccountNotSignedIn"),
      });
    }

    return ok({
      state: CollaborationState.OK,
    });
  } catch (e) {
    return wrapError(e);
  }
}

async function processResult(
  eventName: string | undefined,
  result: Result<null, FxError>,
  inputs?: Inputs
) {
  const envProperty: { [key: string]: string } = {};
  const createProperty: { [key: string]: string } = {};

  if (inputs?.env) {
    envProperty[TelemetryProperty.Env] = getHashedEnv(inputs.env);
    const appInfo = getTeamsAppTelemetryInfoByEnv(inputs.env);
    if (appInfo) {
      envProperty[TelemetryProperty.AppId] = appInfo.appId;
      envProperty[TelemetryProperty.TenantId] = appInfo.tenantId;
    }
  }
  if (eventName == TelemetryEvent.CreateProject && inputs?.projectId) {
    createProperty[TelemetryProperty.NewProjectId] = inputs?.projectId;
  }
  if (eventName === TelemetryEvent.CreateProject && inputs?.isM365) {
    createProperty[TelemetryProperty.IsCreatingM365] = "true";
  }

  if (eventName === TelemetryEvent.Deploy && inputs && inputs["include-aad-manifest"] === "yes") {
    eventName = TelemetryEvent.DeployAadManifest;
  }

  if (result.isErr()) {
    if (eventName) {
      ExtTelemetry.sendTelemetryErrorEvent(eventName, result.error, {
        ...createProperty,
        ...envProperty,
      });
    }
    const error = result.error;
    if (isUserCancelError(error)) {
      return;
    }
    if (isLoginFailureError(error)) {
      window.showErrorMessage(localize("teamstoolkit.handlers.loginFailed"));
      return;
    }
    showError(error);
  } else {
    if (eventName) {
      if (eventName === TelemetryEvent.CreateNewEnvironment) {
        if (inputs?.sourceEnvName) {
          envProperty[TelemetryProperty.SourceEnv] = getHashedEnv(inputs.sourceEnvName);
        }
        if (inputs?.targetEnvName) {
          envProperty[TelemetryProperty.TargetEnv] = getHashedEnv(inputs.targetEnvName);
        }
      }
      ExtTelemetry.sendTelemetryEvent(eventName, {
        [TelemetryProperty.Success]: TelemetrySuccess.Yes,
        ...createProperty,
        ...envProperty,
      });
    }
  }
}

function wrapError(e: Error): Result<null, FxError> {
  if (
    e instanceof UserError ||
    e instanceof SystemError ||
    (e.constructor &&
      e.constructor.name &&
      (e.constructor.name === "SystemError" || e.constructor.name === "UserError"))
  ) {
    return err(e as FxError);
  }
  return err(
    new SystemError({ error: e, source: ExtensionSource, name: ExtensionErrors.UnknwonError })
  );
}

function checkCoreNotEmpty(): Result<null, SystemError> {
  if (!core) {
    return err(
      new SystemError(
        ExtensionSource,
        ExtensionErrors.UnsupportedOperation,
        localize("teamstoolkit.handlers.coreNotReady")
      )
    );
  }
  return ok(null);
}

export async function validateAzureDependenciesHandler(): Promise<string | undefined> {
  if (commonUtils.checkAndSkipDebugging()) {
    // return non-zero value to let task "exit ${command:xxx}" to exit
    return "1";
  }

  ExtTelemetry.sendTelemetryEvent(TelemetryEvent.DebugEnvCheckStart, {
    [TelemetryProperty.DebugProjectComponents]: (await commonUtils.getProjectComponents()) + "",
  });

  const nodeType = (await vscodeHelper.hasFunction()) ? DepsType.FunctionNode : DepsType.AzureNode;
  const deps = [nodeType, DepsType.Dotnet, DepsType.FuncCoreTools, DepsType.Ngrok];

  const vscodeDepsChecker = new VSCodeDepsChecker(vscodeLogger, vscodeTelemetry);
  let shouldContinue = await vscodeDepsChecker.resolve(deps);
  shouldContinue = shouldContinue && (await validatePorts()).isOk();
  ExtTelemetry.sendTelemetryEvent(TelemetryEvent.DebugEnvCheck, {
    [TelemetryProperty.Success]: shouldContinue ? TelemetrySuccess.Yes : TelemetrySuccess.No,
  });

  if (!shouldContinue) {
    await debug.stopDebugging();
    commonUtils.endLocalDebugSession();
    // return non-zero value to let task "exit ${command:xxx}" to exit
    return "1";
  }
}

async function validatePorts(): Promise<Result<void, FxError>> {
  const portsInUse = await commonUtils.getPortsInUse();
  if (portsInUse.length > 0) {
    let message: string;
    if (portsInUse.length > 1) {
      message = util.format(
        localize("teamstoolkit.localDebug.portsAlreadyInUse"),
        portsInUse.join(", ")
      );
    } else {
      message = util.format(localize("teamstoolkit.localDebug.portAlreadyInUse"), portsInUse[0]);
    }
    const error = new UserError(ExtensionSource, ExtensionErrors.PortAlreadyInUse, message);
    VS_CODE_UI.showMessage(
      "error",
      message,
      false,
      localize("teamstoolkit.localDebug.learnMore")
    ).then(async (result) => {
      if (result.isOk() && result.value === localize("teamstoolkit.localDebug.learnMore")) {
        await VS_CODE_UI.openUrl(constants.portInUseHelpLink);
      }
    });
    return err(error);
  }
  return ok(undefined);
}

/**
 * check & install required dependencies during local debug when selected hosting type is SPFx.
 */
export async function validateSpfxDependenciesHandler(): Promise<string | undefined> {
  if (commonUtils.checkAndSkipDebugging()) {
    // return non-zero value to let task "exit ${command:xxx}" to exit
    return "1";
  }

  ExtTelemetry.sendTelemetryEvent(TelemetryEvent.DebugEnvCheckStart, {
    [TelemetryProperty.DebugProjectComponents]: (await commonUtils.getProjectComponents()) + "",
  });

  const vscodeDepsChecker = new VSCodeDepsChecker(vscodeLogger, vscodeTelemetry);
  const shouldContinue = await vscodeDepsChecker.resolve([DepsType.SpfxNode, DepsType.Ngrok]);

  ExtTelemetry.sendTelemetryEvent(TelemetryEvent.DebugEnvCheck, {
    [TelemetryProperty.Success]: shouldContinue ? TelemetrySuccess.Yes : TelemetrySuccess.No,
  });

  if (!shouldContinue) {
    await debug.stopDebugging();
    commonUtils.endLocalDebugSession();
    // return non-zero value to let task "exit ${command:xxx}" to exit
    return "1";
  }
}

/**
 * Check & install required local prerequisites before local debug.
 */
export async function validateLocalPrerequisitesHandler(): Promise<string | undefined> {
  const additionalProperties: { [key: string]: string } = {};
  {
    // If we know this session is concurrently running with another session, send that correlationId in `debug-all-start` event.
    // Mostly, this happens when user stops debugging while preLaunchTasks are running and immediately hit F5 again.
    const session = commonUtils.getLocalDebugSession();
    if (session.id !== commonUtils.DebugNoSessionId) {
      additionalProperties[TelemetryProperty.DebugConcurrentCorrelationId] = session.id;
      // Indicates in which stage (of the first F5) the user hits F5 again.
      additionalProperties[TelemetryProperty.DebugConcurrentLastEventName] =
        localTelemetryReporter.getLastEventName();
    }
  }
  return await Correlator.runWithId(commonUtils.startLocalDebugSession(), async () => {
    if (commonUtils.checkAndSkipDebugging()) {
      // return non-zero value to let task "exit ${command:xxx}" to exit
      return "1";
    }

    await sendDebugAllStartEvent(additionalProperties);
    const result = await localPrerequisites.checkAndInstall();
    if (result.isErr()) {
      // Only local debug use validate-local-prerequisites command
      await sendDebugAllEvent(result.error);
      commonUtils.endLocalDebugSession();
      // return non-zero value to let task "exit ${command:xxx}" to exit
      showError(result.error);
      return "1";
    }
  });
}

/*
 * Prompt window to let user install the app in Teams
 */
export async function installAppInTeams(): Promise<string | undefined> {
  let shouldContinue = false;
  try {
    const debugConfig = await commonUtils.getDebugConfig(
      false,
      environmentManager.getLocalEnvName()
    );
    if (debugConfig?.appId === undefined) {
      throw new UserError(
        ExtensionErrors.GetTeamsAppInstallationFailed,
        ExtensionSource,
        "Debug config not found"
      );
    }
    shouldContinue = await showInstallAppInTeamsMessage(
      environmentManager.getLocalEnvName(),
      debugConfig.appId
    );
  } catch (error: any) {
    showError(error);
  }
  if (!shouldContinue) {
    terminateAllRunningTeamsfxTasks();
    await debug.stopDebugging();
    commonUtils.endLocalDebugSession();
    // return non-zero value to let task "exit ${command:xxx}" to exit
    return "1";
  }
}

/**
 * Check required prerequisites in Get Started Page.
 */
export async function validateGetStartedPrerequisitesHandler(
  args?: any[]
): Promise<string | undefined> {
  ExtTelemetry.sendTelemetryEvent(
    TelemetryEvent.ClickValidatePrerequisites,
    getTriggerFromProperty(args)
  );
  const result = await localPrerequisites.checkPrerequisitesForGetStarted();
  if (result.isErr()) {
    showError(result.error);
    // return non-zero value to let task "exit ${command:xxx}" to exit
    return "1";
  }
}

/**
 * install functions binding before launch local debug
 */
export async function backendExtensionsInstallHandler(): Promise<string | undefined> {
  if (workspace.workspaceFolders && workspace.workspaceFolders.length > 0) {
    const workspaceFolder = workspace.workspaceFolders[0];
    const backendRoot = await commonUtils.getProjectRoot(
      workspaceFolder.uri.fsPath,
      FolderName.Function
    );

    if (backendRoot) {
      const depsChecker = new VSCodeDepsChecker(vscodeLogger, vscodeTelemetry);
      const shouldContinue = await installBackendExtension(backendRoot, depsChecker, vscodeLogger);
      if (!shouldContinue) {
        await debug.stopDebugging();
        // return non-zero value to let task "exit ${command:xxx}" to exit
        return "1";
      }
    }
  }
}

/**
 * Get func binary path to be referenced by task definition.
 * Usage like ${command:...}${env:PATH} so need to include delimiter as well
 */
export async function getFuncPathHandler(): Promise<string> {
  try {
    if (!vscodeHelper.isFuncCoreToolsEnabled()) {
      return `${path.delimiter}`;
    }

    const vscodeDepsChecker = new VSCodeDepsChecker(vscodeLogger, vscodeTelemetry);
    const funcStatus = await vscodeDepsChecker.getDepsStatus(DepsType.FuncCoreTools);
    if (funcStatus?.details?.binFolders !== undefined) {
      return `${path.delimiter}${funcStatus.details.binFolders.join(path.delimiter)}${
        path.delimiter
      }`;
    }
  } catch (error: any) {
    showError(assembleError(error));
  }

  return `${path.delimiter}`;
}

/**
 * Get dotnet path to be referenced by task definition.
 * Usage like ${command:...}${env:PATH} so need to include delimiter as well
 */
export async function getDotnetPathHandler(): Promise<string> {
  try {
    const depsManager = new DepsManager(vscodeLogger, vscodeTelemetry);
    const dotnetStatus = (await depsManager.getStatus([DepsType.Dotnet]))?.[0];
    if (dotnetStatus?.isInstalled && dotnetStatus?.details?.binFolders !== undefined) {
      return `${path.delimiter}${dotnetStatus.details.binFolders.join(path.delimiter)}${
        path.delimiter
      }`;
    }
  } catch (error: any) {
    showError(assembleError(error));
  }

  return `${path.delimiter}`;
}

/**
 * call localDebug on core
 */
export async function preDebugCheckHandler(): Promise<string | undefined> {
  const localAppId = (await commonUtils.getLocalTeamsAppId()) as string;
  const result = await localTelemetryReporter.runWithTelemetryProperties(
    TelemetryEvent.DebugPreCheck,
    {
      [TelemetryProperty.DebugAppId]: localAppId,
    },
    async (): Promise<Result<void, FxError>> => {
      const result = await localTelemetryReporter.runWithTelemetry(
        TelemetryEvent.DebugPreCheckCoreLocalDebug,
        () => {
          VsCodeLogInstance.outputChannel.show();
          return runCommand(Stage.debug);
        }
      );
      if (result.isErr()) {
        return err(result.error);
      }
      return ok(undefined);
    }
  );

  if (result.isErr()) {
    terminateAllRunningTeamsfxTasks();
    await debug.stopDebugging();
    // only local debug uses pre-debug-check command
    await sendDebugAllEvent(result.error);
    commonUtils.endLocalDebugSession();
    // return non-zero value to let task "exit ${command:xxx}" to exit
    return "1";
  }
}

export async function openDocumentHandler(args?: any[]): Promise<Result<boolean, FxError>> {
  ExtTelemetry.sendTelemetryEvent(TelemetryEvent.Documentation, {
    ...getTriggerFromProperty(args),
    [TelemetryProperty.DocumentationName]: "general",
  });
  return VS_CODE_UI.openUrl("https://aka.ms/teamsfx-build-first-app");
}

export async function openAccountLinkHandler(args: any[]): Promise<boolean> {
  ExtTelemetry.sendTelemetryEvent(TelemetryEvent.Documentation, {
    ...getTriggerFromProperty(args),
    [TelemetryProperty.DocumentationName]: "account",
  });
  return env.openExternal(Uri.parse("https://aka.ms/teamsfx-treeview-account"));
}

export async function createAccountHandler(args: any[]): Promise<void> {
  ExtTelemetry.sendTelemetryEvent(TelemetryEvent.CreateAccountStart, getTriggerFromProperty(args));
  const m365Option: OptionItem = {
    id: "createAccountM365",
    label: `$(add) ${localize("teamstoolkit.commands.createAccount.m365")}`,
    description: localize("teamstoolkit.commands.createAccount.free"),
  };
  const azureOption: OptionItem = {
    id: "createAccountAzure",
    label: `$(add) ${localize("teamstoolkit.commands.createAccount.azure")}`,
    description: localize("teamstoolkit.commands.createAccount.free"),
  };
  const option: SingleSelectConfig = {
    name: "CreateAccounts",
    title: localize("teamstoolkit.commands.createAccount.title"),
    options: [m365Option, azureOption],
  };
  const result = await VS_CODE_UI.selectOption(option);
  if (result.isOk()) {
    if (result.value.result === m365Option.id) {
      await VS_CODE_UI.openUrl("https://developer.microsoft.com/microsoft-365/dev-program");
      ExtTelemetry.sendTelemetryEvent(TelemetryEvent.CreateAccount, {
        [TelemetryProperty.AccountType]: AccountType.M365,
        ...getTriggerFromProperty(args),
      });
    } else if (result.value.result === azureOption.id) {
      await VS_CODE_UI.openUrl("https://azure.microsoft.com/en-us/free/");
      ExtTelemetry.sendTelemetryEvent(TelemetryEvent.CreateAccount, {
        [TelemetryProperty.AccountType]: AccountType.Azure,
        ...getTriggerFromProperty(args),
      });
    }
  } else {
    ExtTelemetry.sendTelemetryErrorEvent(TelemetryEvent.CreateAccount, result.error, {
      ...getTriggerFromProperty(args),
    });
  }
  return;
}

export async function openEnvLinkHandler(args: any[]): Promise<boolean> {
  ExtTelemetry.sendTelemetryEvent(TelemetryEvent.Documentation, {
    ...getTriggerFromProperty(args),
    [TelemetryProperty.DocumentationName]: "environment",
  });
  return env.openExternal(Uri.parse("https://aka.ms/teamsfx-treeview-environment"));
}

export async function openDevelopmentLinkHandler(args: any[]): Promise<boolean> {
  ExtTelemetry.sendTelemetryEvent(TelemetryEvent.Documentation, {
    ...getTriggerFromProperty(args),
    [TelemetryProperty.DocumentationName]: "development",
  });
  return env.openExternal(Uri.parse("https://aka.ms/teamsfx-treeview-development"));
}

export async function openDeploymentLinkHandler(args: any[]): Promise<boolean> {
  ExtTelemetry.sendTelemetryEvent(TelemetryEvent.Documentation, {
    ...getTriggerFromProperty(args),
    [TelemetryProperty.DocumentationName]: "deployment",
  });
  return env.openExternal(Uri.parse("https://aka.ms/teamsfx-treeview-deployment"));
}

export async function openHelpFeedbackLinkHandler(args: any[]): Promise<boolean> {
  ExtTelemetry.sendTelemetryEvent(TelemetryEvent.Documentation, {
    ...getTriggerFromProperty(args),
    [TelemetryProperty.DocumentationName]: "help&feedback",
  });
  return env.openExternal(Uri.parse("https://aka.ms/teamsfx-treeview-helpnfeedback"));
}
export async function openWelcomeHandler(args?: any[]): Promise<Result<unknown, FxError>> {
  ExtTelemetry.sendTelemetryEvent(TelemetryEvent.GetStarted, getTriggerFromProperty(args));
  const data = await vscode.commands.executeCommand(
    "workbench.action.openWalkthrough",
    "TeamsDevApp.ms-teams-vscode-extension#teamsToolkitGetStarted"
  );
  return Promise.resolve(ok(data));
}

export async function checkUpgrade(args?: any[]) {
  // just for triggering upgrade check for multi-env && bicep.
  await runCommand(Stage.listCollaborator);
}

export async function openSurveyHandler(args?: any[]) {
  WebviewPanel.createOrShow(PanelType.Survey);
}

export async function autoOpenProjectHandler(): Promise<void> {
  const isOpenWalkThrough = await globalStateGet(GlobalKey.OpenWalkThrough, false);
  const isOpenReadMe = await globalStateGet(GlobalKey.OpenReadMe, "");
  const isOpenSampleReadMe = await globalStateGet(GlobalKey.OpenSampleReadMe, false);
  if (isOpenWalkThrough) {
    showLocalDebugMessage();
    showLocalPreviewMessage();
    await openWelcomeHandler([TelemetryTriggerFrom.Auto]);
    await globalStateUpdate(GlobalKey.OpenWalkThrough, false);
  }
  if (isOpenReadMe === globalVariables.workspaceUri?.fsPath) {
    showLocalDebugMessage();
    showLocalPreviewMessage();
    await openReadMeHandler([TelemetryTriggerFrom.Auto]);
    await globalStateUpdate(GlobalKey.OpenReadMe, "");
  }
  if (isOpenSampleReadMe) {
    showLocalDebugMessage();
    showLocalPreviewMessage();
    await openSampleReadmeHandler([TelemetryTriggerFrom.Auto]);
    await globalStateUpdate(GlobalKey.OpenSampleReadMe, false);
  }
}

export async function openReadMeHandler(args: any[]) {
  ExtTelemetry.sendTelemetryEvent(TelemetryEvent.ClickOpenReadMe, getTriggerFromProperty(args));
  if (!globalVariables.isTeamsFxProject) {
    const createProject = {
      title: localize("teamstoolkit.handlers.createProjectTitle"),
      run: async (): Promise<void> => {
        Correlator.run(() => createNewProjectHandler([TelemetryTriggerFrom.Notification]));
      },
    };

    const openFolder = {
      title: localize("teamstoolkit.handlers.openFolderTitle"),
      run: async (): Promise<void> => {
        commands.executeCommand("vscode.openFolder");
      },
    };

    vscode.window
      .showInformationMessage(
        localize("teamstoolkit.handlers.createProjectNotification"),
        createProject,
        openFolder
      )
      .then((selection) => {
        selection?.run();
      });
  } else if (workspace.workspaceFolders && workspace.workspaceFolders.length > 0) {
    const workspaceFolder = workspace.workspaceFolders[0];
    const workspacePath: string = workspaceFolder.uri.fsPath;
    let targetFolder: string | undefined;
    if (await getIsFromSample()) {
      openSampleReadmeHandler(args);
    } else if (globalVariables.isSPFxProject) {
      targetFolder = `${workspacePath}/SPFx`;
    } else {
      const tabFolder = await commonUtils.getProjectRoot(workspacePath, FolderName.Frontend);
      const botFolder = await commonUtils.getProjectRoot(workspacePath, FolderName.Bot);

      if (tabFolder && botFolder) {
        targetFolder = workspacePath;
      } else if (tabFolder) {
        targetFolder = tabFolder;
      } else if (botFolder) {
        targetFolder = botFolder;
      } else {
        // minimal teamsfx project
        targetFolder = workspacePath;
      }
    }
    // When tab and bot coexist, readme file would reside in project root folder.
    // Naming it README.md could accidently overwrite our users' own readme file.
    // So we name it README-auto-generated.md here.
    const autoGeneratedReadmePath = `${targetFolder}/${AutoGeneratedReadme}`;
    const uri = (await fs.pathExists(autoGeneratedReadmePath))
      ? Uri.file(autoGeneratedReadmePath)
      : Uri.file(`${targetFolder}/README.md`);

    // Always open README.md in current panel instead of side-by-side.
    workspace.openTextDocument(uri).then(() => {
      const PreviewMarkdownCommand = "markdown.showPreview";
      commands.executeCommand(PreviewMarkdownCommand, uri);
    });
  }
}

export async function promptSPFxUpgrade() {
  if (globalVariables.isSPFxProject) {
    let projectSPFxVersion = null;
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion, @typescript-eslint/no-non-null-asserted-optional-chain
    const yoInfoPath = path.join(globalVariables.workspaceUri?.fsPath!, "SPFx", ".yo-rc.json");
    if (await fs.pathExists(yoInfoPath)) {
      const yoInfo = await fs.readJson(yoInfoPath);
      projectSPFxVersion = yoInfo["@microsoft/generator-sharepoint"]?.version;
    }

    if (!projectSPFxVersion) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion, @typescript-eslint/no-non-null-asserted-optional-chain
      const packagePath = path.join(globalVariables.workspaceUri?.fsPath!, "SPFx", "package.json");
      if (await fs.pathExists(packagePath)) {
        const packageInfo = await fs.readJSON(packagePath);
        projectSPFxVersion = packageInfo.dependencies["@microsoft/sp-webpart-base"];
      }
    }

    if (projectSPFxVersion) {
      const cmp = compare(projectSPFxVersion, SUPPORTED_SPFX_VERSION);
      const cmpPrerelease = compare(projectSPFxVersion, SUPPORTED_SPFX_PRERELEASE_VERSION);

      if (cmp === 0 || cmpPrerelease === 0) {
        return;
      }
      if (cmp === cmpPrerelease) {
        const spfxVersion =
          getSPFxVersion() === "1.15.0"
            ? SUPPORTED_SPFX_VERSION
            : SUPPORTED_SPFX_PRERELEASE_VERSION;
        const args: string[] = cmp === 1 ? [spfxVersion] : [spfxVersion, spfxVersion];
        VS_CODE_UI.showMessage(
          "warn",
          util.format(
            localize(
              cmp === 1
                ? "teamstoolkit.handlers.promptSPFx.upgradeToolkit.description"
                : "teamstoolkit.handlers.promptSPFx.upgradeProject.description"
            ),
            ...args
          ),
          false,
          localize(
            cmp === 1
              ? "teamstoolkit.handlers.promptSPFx.upgradeToolkit.title"
              : "teamstoolkit.handlers.promptSPFx.upgradeProject.title"
          )
        ).then(async (result) => {
          if (result.isOk()) {
            if (
              result.value === localize("teamstoolkit.handlers.promptSPFx.upgradeToolkit.title")
            ) {
              await vscode.commands.executeCommand("workbench.extensions.search", "Teams Toolkit");
            } else if (
              result.value === localize("teamstoolkit.handlers.promptSPFx.upgradeProject.title")
            ) {
              await VS_CODE_UI.openUrl(CLI_FOR_M365);
            }
          }
        });
      }
    }
  }
}

export async function postUpgrade(): Promise<void> {
  await openUpgradeChangeLogsHandler();
  await popupAfterUpgrade();
}

async function popupAfterUpgrade(): Promise<void> {
  const aadClientSecretFlag = "NeedToSetAADClientSecretEnv";
  const aadClientSecret = await globalStateGet(aadClientSecretFlag, "");
  if (
    aadClientSecret !== "" &&
    workspace.workspaceFolders &&
    workspace.workspaceFolders.length > 0
  ) {
    try {
      const learnMoreLink = localize("teamstoolkit.upgradeToMultiEnvAndBicep.learnMoreLink");
      const learnMoreText = localize("teamstoolkit.upgradeToMultiEnvAndBicep.learnMoreText");
      const option = { modal: false };
      const outputMsg = util.format(
        localize("teamstoolkit.upgradeToMultiEnvAndBicep.outputMsg"),
        aadClientSecret,
        learnMoreLink
      );
      const showMsg = util.format(
        localize("teamstoolkit.upgradeToMultiEnvAndBicep.showMsg"),
        aadClientSecret
      );
      VsCodeLogInstance.warning(outputMsg);
      window.showWarningMessage(showMsg, option, learnMoreText).then((result) => {
        if (result === learnMoreText) {
          return env.openExternal(Uri.parse(learnMoreLink));
        }
      });
    } finally {
      await globalStateUpdate(aadClientSecretFlag, "");
    }
  }
}

async function openUpgradeChangeLogsHandler() {
  const openUpgradeChangelogsFlag = "openUpgradeChangelogs";
  if (
    (await globalStateGet(openUpgradeChangelogsFlag, false)) &&
    workspace.workspaceFolders &&
    workspace.workspaceFolders.length > 0
  ) {
    try {
      await globalStateUpdate(openUpgradeChangelogsFlag, false);

      const workspacePath: string = workspace.workspaceFolders[0].uri.fsPath;
      const backupName = ".backup";
      const changeLogsName = "upgrade-change-logs.md";
      const changeLogsPath: string = (await fs.pathExists(
        path.join(workspacePath, backupName, changeLogsName)
      ))
        ? path.join(workspacePath, backupName, changeLogsName)
        : path.join(workspacePath, `.teamsfx${backupName}`, changeLogsName);
      const uri = Uri.file(changeLogsPath);

      workspace.openTextDocument(uri).then(() => {
        const PreviewMarkdownCommand = "markdown.showPreview";
        commands.executeCommand(PreviewMarkdownCommand, uri);
      });
    } catch (err) {
      // do nothing
    }
  }
}

async function openSampleReadmeHandler(args?: any) {
  if (workspace.workspaceFolders && workspace.workspaceFolders.length > 0) {
    const workspaceFolder = workspace.workspaceFolders[0];
    const workspacePath: string = workspaceFolder.uri.fsPath;
    const uri = Uri.file(`${workspacePath}/README.md`);
    workspace.openTextDocument(uri).then(() => {
      if (isTriggerFromWalkThrough(args)) {
        const PreviewMarkdownCommand = "markdown.showPreviewToSide";
        commands.executeCommand(PreviewMarkdownCommand, uri);
      } else {
        const PreviewMarkdownCommand = "markdown.showPreview";
        commands.executeCommand(PreviewMarkdownCommand, uri);
      }
    });
  }
}

async function showLocalDebugMessage() {
  const isShowLocalDebugMessage = await globalStateGet(GlobalKey.ShowLocalDebugMessage, false);

  if (!isShowLocalDebugMessage) {
    return;
  } else {
    await globalStateUpdate(GlobalKey.ShowLocalDebugMessage, false);
  }

  const localDebug = {
    title: localize("teamstoolkit.handlers.localDebugTitle"),
    run: async (): Promise<void> => {
      selectAndDebug();
    },
  };

  ExtTelemetry.sendTelemetryEvent(TelemetryEvent.ShowLocalDebugNotification);
  const appName = getAppName() ?? "Teams App";
  const isWindows = process.platform === "win32";
  let message = util.format(
    localize("teamstoolkit.handlers.localDebugDescription.fallback"),
    appName,
    globalVariables.workspaceUri?.fsPath
  );
  if (isWindows) {
    const folderLink = encodeURI(globalVariables.workspaceUri!.toString());
    const openFolderCommand = `command:fx-extension.openFolder?%5B%22${folderLink}%22%5D`;
    message = util.format(
      localize("teamstoolkit.handlers.localDebugDescription"),
      appName,
      openFolderCommand
    );
  }
  vscode.window.showInformationMessage(message, localDebug).then((selection) => {
    if (selection?.title === localize("teamstoolkit.handlers.localDebugTitle")) {
      ExtTelemetry.sendTelemetryEvent(TelemetryEvent.ClickLocalDebug);
      selection.run();
    }
  });
}

async function showLocalPreviewMessage() {
  const isShowLocalPreviewMessage = await globalStateGet(GlobalKey.ShowLocalPreviewMessage, false);

  if (!isShowLocalPreviewMessage) {
    return;
  } else {
    await globalStateUpdate(GlobalKey.ShowLocalPreviewMessage, false);
  }

  const localPreview = {
    title: localize("teamstoolkit.handlers.localPreviewTitle"),
    run: async (): Promise<void> => {
      treeViewPreviewHandler(environmentManager.getLocalEnvName());
    },
  };

  ExtTelemetry.sendTelemetryEvent(TelemetryEvent.ShowLocalPreviewNotification);
  const appName = getAppName() ?? "Teams App";
  const isWindows = process.platform === "win32";
  let message = util.format(
    localize("teamstoolkit.handlers.localPreviewDescription.fallback"),
    appName,
    globalVariables.workspaceUri?.fsPath
  );
  if (isWindows) {
    const folderLink = encodeURI(globalVariables.workspaceUri!.toString());
    const openFolderCommand = `command:fx-extension.openFolder?%5B%22${folderLink}%22%5D`;
    message = util.format(
      localize("teamstoolkit.handlers.localPreviewDescription"),
      appName,
      openFolderCommand
    );
  }
  vscode.window.showInformationMessage(message, localPreview).then((selection) => {
    if (selection?.title === localize("teamstoolkit.handlers.localPreviewTitle")) {
      ExtTelemetry.sendTelemetryEvent(TelemetryEvent.ClickLocalPreview);
      selection.run();
    }
  });
}

export async function openSamplesHandler(args?: any[]): Promise<Result<null, FxError>> {
  ExtTelemetry.sendTelemetryEvent(TelemetryEvent.Samples, getTriggerFromProperty(args));
  WebviewPanel.createOrShow(PanelType.SampleGallery, isTriggerFromWalkThrough(args));
  return Promise.resolve(ok(null));
}

export async function openAppManagement(args?: any[]): Promise<Result<boolean, FxError>> {
  ExtTelemetry.sendTelemetryEvent(TelemetryEvent.ManageTeamsApp, getTriggerFromProperty(args));
  return VS_CODE_UI.openUrl("https://dev.teams.microsoft.com/home");
}

export async function openBotManagement(args?: any[]) {
  ExtTelemetry.sendTelemetryEvent(TelemetryEvent.ManageTeamsBot, getTriggerFromProperty(args));
  return env.openExternal(Uri.parse("https://dev.teams.microsoft.com/bots"));
}

export async function openReportIssues(args?: any[]): Promise<Result<boolean, FxError>> {
  ExtTelemetry.sendTelemetryEvent(TelemetryEvent.ReportIssues, getTriggerFromProperty(args));
  return VS_CODE_UI.openUrl("https://github.com/OfficeDev/TeamsFx/issues");
}

export async function openExternalHandler(args?: any[]) {
  if (args && args.length > 0) {
    const url = args[0].url;
    return env.openExternal(Uri.parse(url));
  }
}

export async function openManifestHandler(args?: any[]): Promise<Result<null, FxError>> {
  ExtTelemetry.sendTelemetryEvent(
    TelemetryEvent.OpenManifestEditorStart,
    getTriggerFromProperty(args)
  );
  const projectPath = globalVariables.workspaceUri?.fsPath;
  if (!projectPath) {
    ExtTelemetry.sendTelemetryErrorEvent(
      TelemetryEvent.OpenManifestEditor,
      new InvalidProjectError()
    );
    return err(new InvalidProjectError());
  }
  const appDirectory = await getAppDirectory(projectPath!);
  if (!(await fs.pathExists(appDirectory))) {
    const invalidProjectError: FxError = new InvalidProjectError();
    showError(invalidProjectError);
    ExtTelemetry.sendTelemetryErrorEvent(TelemetryEvent.OpenManifestEditor, invalidProjectError);
    return err(invalidProjectError);
  }

  const func: Func = {
    namespace: "fx-solution-azure/fx-resource-appstudio",
    method: "getManifestTemplatePath",
    params: {
      type: "remote",
    },
  };
  const res = await runUserTask(func, TelemetryEvent.OpenManifestEditor, true);
  if (res.isOk()) {
    const manifestFile = res.value as string;
    if (fs.existsSync(manifestFile)) {
      workspace.openTextDocument(manifestFile).then((document) => {
        window.showTextDocument(document);
      });
      ExtTelemetry.sendTelemetryEvent(TelemetryEvent.OpenManifestEditor, {
        [TelemetryProperty.Success]: TelemetrySuccess.Yes,
      });
      return ok(null);
    } else {
      const FxError = new SystemError(
        ExtensionSource,
        "FileNotFound",
        util.format(localize("teamstoolkit.handlers.fileNotFound"), manifestFile)
      );
      showError(FxError);
      ExtTelemetry.sendTelemetryErrorEvent(TelemetryEvent.OpenManifestEditor, FxError);
      return err(FxError);
    }
  } else {
    showError(res.error);
    ExtTelemetry.sendTelemetryErrorEvent(TelemetryEvent.OpenManifestEditor, res.error);
    return err(res.error);
  }
}

export async function createNewEnvironment(args?: any[]): Promise<Result<Void, FxError>> {
  ExtTelemetry.sendTelemetryEvent(
    TelemetryEvent.CreateNewEnvironmentStart,
    getTriggerFromProperty(args)
  );
  const result = await runCommand(Stage.createEnv);
  if (!result.isErr()) {
    await envTreeProviderInstance.reloadEnvironments();
  }
  return result;
}

export async function refreshEnvironment(args?: any[]): Promise<Result<Void, FxError>> {
  return await envTreeProviderInstance.reloadEnvironments();
}

function getSubscriptionUrl(subscriptionInfo: SubscriptionInfo): string {
  const subscriptionId = subscriptionInfo.subscriptionId;
  const tenantId = subscriptionInfo.tenantId;

  return `${AzurePortalUrl}/#@${tenantId}/resource/subscriptions/${subscriptionId}`;
}

enum ResourceInfo {
  Subscription = "Subscription",
  ResourceGroup = "Resource Group",
}

export async function openSubscriptionInPortal(env: string): Promise<Result<Void, FxError>> {
  const telemetryProperties: { [p: string]: string } = {};
  telemetryProperties[TelemetryProperty.Env] = getHashedEnv(env);

  const subscriptionInfo = await getSubscriptionInfoFromEnv(env);
  if (subscriptionInfo) {
    ExtTelemetry.sendTelemetryEvent(TelemetryEvent.OpenSubscriptionInPortal, telemetryProperties);

    const url = getSubscriptionUrl(subscriptionInfo);
    await vscode.env.openExternal(vscode.Uri.parse(url));

    return ok(Void);
  } else {
    const resourceInfoNotFoundError = new UserError(
      ExtensionSource,
      ExtensionErrors.EnvResourceInfoNotFoundError,
      util.format(
        localize("teamstoolkit.handlers.resourceInfoNotFound"),
        ResourceInfo.Subscription,
        env
      )
    );
    ExtTelemetry.sendTelemetryErrorEvent(
      TelemetryEvent.OpenSubscriptionInPortal,
      resourceInfoNotFoundError,
      telemetryProperties
    );

    return err(resourceInfoNotFoundError);
  }
}

export async function openResourceGroupInPortal(env: string): Promise<Result<Void, FxError>> {
  const telemetryProperties: { [p: string]: string } = {};
  telemetryProperties[TelemetryProperty.Env] = getHashedEnv(env);

  const subscriptionInfo = await getSubscriptionInfoFromEnv(env);
  const resourceGroupName = await getResourceGroupNameFromEnv(env);

  if (subscriptionInfo && resourceGroupName) {
    ExtTelemetry.sendTelemetryEvent(TelemetryEvent.OpenResourceGroupInPortal, telemetryProperties);

    const url = `${getSubscriptionUrl(subscriptionInfo)}/resourceGroups/${resourceGroupName}`;
    await vscode.env.openExternal(vscode.Uri.parse(url));

    return ok(Void);
  } else {
    let errorMessage = "";
    if (subscriptionInfo) {
      errorMessage = util.format(
        localize("teamstoolkit.handlers.resourceInfoNotFound"),
        ResourceInfo.ResourceGroup,
        env
      );
    } else if (resourceGroupName) {
      errorMessage = util.format(
        localize("teamstoolkit.handlers.resourceInfoNotFound"),
        ResourceInfo.Subscription,
        env
      );
    } else {
      errorMessage = util.format(
        localize("teamstoolkit.handlers.resourceInfoNotFound"),
        `${ResourceInfo.Subscription} and ${ResourceInfo.ResourceGroup}`,
        env
      );
    }

    const resourceInfoNotFoundError = new UserError(
      ExtensionSource,
      ExtensionErrors.EnvResourceInfoNotFoundError,
      errorMessage
    );
    ExtTelemetry.sendTelemetryErrorEvent(
      TelemetryEvent.OpenSubscriptionInPortal,
      resourceInfoNotFoundError,
      telemetryProperties
    );

    return err(resourceInfoNotFoundError);
  }
}

export async function grantPermission(env: string): Promise<Result<any, FxError>> {
  let result: Result<any, FxError> = ok(Void);
  ExtTelemetry.sendTelemetryEvent(TelemetryEvent.GrantPermissionStart);

  let inputs: Inputs | undefined;
  try {
    const checkCoreRes = checkCoreNotEmpty();
    if (checkCoreRes.isErr()) {
      throw checkCoreRes.error;
    }

    const collaborationStateResult = await checkCollaborationState(env);
    if (collaborationStateResult.isErr()) {
      throw collaborationStateResult.error;
    }

    if (collaborationStateResult.value.state === CollaborationState.OK) {
      inputs = getSystemInputs();
      inputs.env = env;
      result = await core.grantPermission(inputs);
      if (result.isErr()) {
        throw result.error;
      }
      const grantSucceededMsg = util.format(
        localize("teamstoolkit.handlers.grantPermissionSucceeded"),
        inputs.email,
        env
      );

      let warningMsg = localize("teamstoolkit.handlers.grantPermissionWarning");
      let helpUrl = AzureAssignRoleHelpUrl;
      if (globalVariables.isSPFxProject) {
        warningMsg = localize("teamstoolkit.handlers.grantPermissionWarningSpfx");
        helpUrl = SpfxManageSiteAdminUrl;
      }

      showGrantSuccessMessageWithGetHelpButton(grantSucceededMsg + " " + warningMsg, helpUrl);

      VsCodeLogInstance.info(grantSucceededMsg);
      VsCodeLogInstance.warning(
        warningMsg + localize("teamstoolkit.handlers.referLinkForMoreDetails") + helpUrl
      );
    } else {
      result = collaborationStateResult;
      if (result.value.state === CollaborationState.NotProvisioned) {
        showWarningMessageWithProvisionButton(result.value.message);
      } else {
        window.showWarningMessage(result.value.message);
      }
    }
  } catch (e) {
    result = wrapError(e);
  }

  await processResult(TelemetryEvent.GrantPermission, result, inputs);
  return result;
}

export async function listCollaborator(env: string): Promise<void> {
  let result: Result<any, FxError> = ok(Void);
  ExtTelemetry.sendTelemetryEvent(TelemetryEvent.ListCollaboratorStart);

  let inputs: Inputs | undefined;
  try {
    const checkCoreRes = checkCoreNotEmpty();
    if (checkCoreRes.isErr()) {
      throw checkCoreRes.error;
    }

    const collaborationStateResult = await checkCollaborationState(env);
    if (collaborationStateResult.isErr()) {
      throw collaborationStateResult.error;
    }

    if (collaborationStateResult.value.state === CollaborationState.OK) {
      inputs = getSystemInputs();
      inputs.env = env;

      result = await core.listCollaborator(inputs);
      if (result.isErr()) {
        throw result.error;
      }

      // TODO: For short-term workaround. Remove after webview is ready.
      VsCodeLogInstance.outputChannel.show();
    } else {
      result = collaborationStateResult;
      if (result.value.state === CollaborationState.NotProvisioned) {
        showWarningMessageWithProvisionButton(result.value.message);
      } else {
        window.showWarningMessage(result.value.message);
      }
    }
  } catch (e) {
    result = wrapError(e);
  }

  await processResult(TelemetryEvent.ListCollaborator, result, inputs);
}

export async function openM365AccountHandler() {
  ExtTelemetry.sendTelemetryEvent(TelemetryEvent.OpenM365Portal);
  return env.openExternal(Uri.parse("https://admin.microsoft.com/Adminportal/"));
}

export async function openAzureAccountHandler() {
  ExtTelemetry.sendTelemetryEvent(TelemetryEvent.OpenAzurePortal);
  return env.openExternal(Uri.parse("https://portal.azure.com/"));
}

export function saveTextDocumentHandler(document: vscode.TextDocumentWillSaveEvent) {
  if (!isValidProject(globalVariables.workspaceUri?.fsPath)) {
    return;
  }

  let reason: TelemetryUpdateAppReason | undefined = undefined;
  switch (document.reason) {
    case vscode.TextDocumentSaveReason.Manual:
      reason = TelemetryUpdateAppReason.Manual;
      break;
    case vscode.TextDocumentSaveReason.AfterDelay:
      reason = TelemetryUpdateAppReason.AfterDelay;
      break;
    case vscode.TextDocumentSaveReason.FocusOut:
      reason = TelemetryUpdateAppReason.FocusOut;
      break;
  }

  let curDirectory = path.dirname(document.document.fileName);
  while (curDirectory) {
    if (isValidProject(curDirectory)) {
      ExtTelemetry.sendTelemetryEvent(TelemetryEvent.UpdateTeamsApp, {
        [TelemetryProperty.UpdateTeamsAppReason]: reason,
      });
      return;
    }

    if (curDirectory === path.join(curDirectory, "..")) {
      break;
    }
    curDirectory = path.join(curDirectory, "..");
  }
}

export async function cmdHdlLoadTreeView(context: ExtensionContext) {
  // Keeping legacy codes because customized treeview is blocked by VS Code bug
  // if (
  //   await exp
  //     .getExpService()
  //     .getTreatmentVariableAsync(
  //       TreatmentVariables.VSCodeConfig,
  //       TreatmentVariables.CustomizeTreeview,
  //       true
  //     )
  // ) {
  //   vscode.commands.executeCommand("setContext", "fx-extension.customizedTreeview", true);
  // } else {
  //   vscode.commands.executeCommand("setContext", "fx-extension.customizedTreeview", false);
  // }
}

export function registerAccountMenuCommands(context: ExtensionContext) {
  // Register SignOut tree view command
  context.subscriptions.push(
    commands.registerCommand("fx-extension.signOut", async (node: TreeViewCommand) => {
      try {
        switch (node.contextValue) {
          case "signedinM365": {
            Correlator.run(() => {
              signOutM365(true);
            });
            break;
          }
          case "signedinAzure": {
            Correlator.run(() => {
              signOutAzure(true);
            });
            break;
          }
        }
      } catch (e) {
        showError(e);
      }
    })
  );
}

export function cmdHdlDisposeTreeView() {
  TreeViewManagerInstance.dispose();
}

export async function showError(e: UserError | SystemError) {
  const notificationMessage = e.displayMessage ?? e.message;

  if (e.stack && e instanceof SystemError) {
    VsCodeLogInstance.error(`code:${e.source}.${e.name}, message: ${e.message}, stack: ${e.stack}`);
  } else {
    VsCodeLogInstance.error(`code:${e.source}.${e.name}, message: ${e.message}`);
  }

  const errorCode = `${e.source}.${e.name}`;
  if (isUserCancelError(e)) {
    return;
  } else if ("helpLink" in e && e.helpLink && typeof e.helpLink != "undefined") {
    const help = {
      title: localize("teamstoolkit.handlers.getHelp"),
      run: async (): Promise<void> => {
        ExtTelemetry.sendTelemetryEvent(TelemetryEvent.ClickGetHelp, {
          [TelemetryProperty.ErrorCode]: errorCode,
          [TelemetryProperty.ErrorMessage]: notificationMessage,
          [TelemetryProperty.HelpLink]: e.helpLink!,
        });
        commands.executeCommand("vscode.open", Uri.parse(`${e.helpLink}#${e.source}${e.name}`));
      },
    };

    const button = await window.showErrorMessage(`[${errorCode}]: ${notificationMessage}`, help);
    if (button) await button.run();
  } else if (e instanceof SystemError) {
    const sysError = e as SystemError;
    const path = "https://github.com/OfficeDev/TeamsFx/issues/new?";
    const param = `title=bug+report: ${errorCode}&body=${anonymizeFilePaths(
      e.message
    )}\n\nstack:\n${anonymizeFilePaths(e.stack)}\n\n${
      sysError.userData ? anonymizeFilePaths(sysError.userData) : ""
    }`;
    const issue = {
      title: localize("teamstoolkit.handlers.reportIssue"),
      run: async (): Promise<void> => {
        commands.executeCommand("vscode.open", Uri.parse(`${path}${param}`));
      },
    };

    const button = await window.showErrorMessage(`[${errorCode}]: ${notificationMessage}`, issue);
    if (button) await button.run();
  } else {
    if (!(e instanceof ConcurrentError))
      await window.showErrorMessage(`[${errorCode}]: ${notificationMessage}`);
  }
}

export async function cmpAccountsHandler(args: any[]) {
  ExtTelemetry.sendTelemetryEvent(TelemetryEvent.ManageAccount, getTriggerFromProperty(args));
  const signInAzureOption: VscQuickPickItem = {
    id: "signInAzure",
    label: localize("teamstoolkit.handlers.signInAzure"),
    function: () => signInAzure(),
  };

  const signOutAzureOption: VscQuickPickItem = {
    id: "signOutAzure",
    label: localize("teamstoolkit.handlers.signOutOfAzure"),
    function: async () =>
      Correlator.run(() => {
        signOutAzure(false);
      }),
  };

  const signInM365Option: VscQuickPickItem = {
    id: "signinM365",
    label: localize("teamstoolkit.handlers.signIn365"),
    function: () => signInM365(),
  };

  const signOutM365Option: VscQuickPickItem = {
    id: "signOutM365",
    label: localize("teamstoolkit.handlers.signOutOfM365"),
    function: async () =>
      Correlator.run(() => {
        signOutM365(false);
      }),
  };

  const createAccountsOption: VscQuickPickItem = {
    id: "createAccounts",
    label: `$(add) ${localize("teamstoolkit.commands.createAccount.title")}`,
    function: async () => {
      Correlator.run(() => createAccountHandler([]));
    },
  };

  //TODO: hide subscription list until core or api expose the get subscription list API
  // let selectSubscriptionOption: VscQuickPickItem = {
  //   id: "selectSubscription",
  //   label: "Specify an Azure Subscription",
  //   function: () => selectSubscription(),
  //   detail: "4 subscriptions discovered"
  // };

  const quickPick = window.createQuickPick();

  const quickItemOptionArray: VscQuickPickItem[] = [];

  const m365AccountRes = await M365TokenInstance.getStatus({ scopes: AppStudioScopes });
  const m365Account = m365AccountRes.isOk() ? m365AccountRes.value : undefined;
  if (m365Account && m365Account.status === "SignedIn") {
    const accountInfo = m365Account.accountInfo;
    const email = (accountInfo as any).upn ? (accountInfo as any).upn : undefined;
    if (email !== undefined) {
      signOutM365Option.label = signOutM365Option.label.concat(email);
    }
    quickItemOptionArray.push(signOutM365Option);
  } else {
    quickItemOptionArray.push(signInM365Option);
  }

  const solutionSettings = await getAzureSolutionSettings();
  // if non-teamsfx project or Azure project then show Azure account info
  if (!solutionSettings || (solutionSettings && "Azure" === solutionSettings.hostType)) {
    const azureAccount = await AzureAccountManager.getStatus();
    if (azureAccount.status === "SignedIn") {
      const accountInfo = azureAccount.accountInfo;
      const email = (accountInfo as any).upn ? (accountInfo as any).upn : undefined;
      if (email !== undefined) {
        signOutAzureOption.label = signOutAzureOption.label.concat(email);
      }
      quickItemOptionArray.push(signOutAzureOption);
      //quickItemOptionArray.push(selectSubscriptionOption);
    } else {
      quickItemOptionArray.push(signInAzureOption);
    }
  }

  quickItemOptionArray.push(createAccountsOption);
  quickPick.items = quickItemOptionArray;
  quickPick.onDidChangeSelection((selection) => {
    if (selection[0]) {
      (selection[0] as VscQuickPickItem).function().catch(console.error);
    }
  });
  quickPick.onDidHide(() => quickPick.dispose());
  quickPick.show();
}

export async function decryptSecret(cipher: string, selection: vscode.Range): Promise<void> {
  ExtTelemetry.sendTelemetryEvent(TelemetryEvent.EditSecretStart, {
    [TelemetryProperty.TriggerFrom]: TelemetryTriggerFrom.Other,
  });
  const editor = vscode.window.activeTextEditor;
  if (!editor) {
    return;
  }
  const inputs = getSystemInputs();
  const result = await core.decrypt(cipher, inputs);
  if (result.isOk()) {
    const editedSecret = await VS_CODE_UI.inputText({
      name: "Secret Editor",
      title: localize("teamstoolkit.handlers.editSecretTitle"),
      default: result.value,
    });
    if (editedSecret.isOk() && editedSecret.value.result) {
      const newCiphertext = await core.encrypt(editedSecret.value.result, inputs);
      if (newCiphertext.isOk()) {
        editor.edit((editBuilder) => {
          editBuilder.replace(selection, newCiphertext.value);
        });
        ExtTelemetry.sendTelemetryEvent(TelemetryEvent.EditSecret, {
          [TelemetryProperty.Success]: TelemetrySuccess.Yes,
        });
      } else {
        ExtTelemetry.sendTelemetryErrorEvent(TelemetryEvent.EditSecret, newCiphertext.error);
      }
    }
  } else {
    ExtTelemetry.sendTelemetryErrorEvent(TelemetryEvent.EditSecret, result.error);
    window.showErrorMessage(localize("teamstoolkit.handlers.decryptFailed"));
  }
}

export async function openAdaptiveCardExt(
  args: any[] = [TelemetryTriggerFrom.TreeView]
): Promise<Result<unknown, FxError>> {
  ExtTelemetry.sendTelemetryEvent(TelemetryEvent.PreviewAdaptiveCard, getTriggerFromProperty(args));
  const acExtId = "madewithcardsio.adaptivecardsstudiobeta";
  const extension = vscode.extensions.getExtension(acExtId);
  if (!extension) {
    vscode.window
      .showInformationMessage(
        localize("teamstoolkit.handlers.installAdaptiveCardExt"),
        "Install",
        "Cancel"
      )
      .then(async (selection) => {
        if (selection === "Install") {
          await vscode.commands.executeCommand("workbench.extensions.installExtension", acExtId);
          await vscode.commands.executeCommand("workbench.view.extension.cardLists");
        }
      });
  } else {
    await vscode.commands.executeCommand("workbench.view.extension.cardLists");
  }
  return Promise.resolve(ok(null));
}

export async function openPreviewAadFile(args: any[]): Promise<Result<any, FxError>> {
  ExtTelemetry.sendTelemetryEvent(
    TelemetryEvent.PreviewAadManifestFile,
    getTriggerFromProperty(args)
  );
  const workspacePath = globalVariables.workspaceUri?.fsPath;
  const validProject = isValidProject(workspacePath);
  if (!validProject) {
    ExtTelemetry.sendTelemetryErrorEvent(
      TelemetryEvent.PreviewAadManifestFile,
      new InvalidProjectError()
    );
    return err(new InvalidProjectError());
  }

  const selectedEnv = await askTargetEnvironment();
  if (selectedEnv.isErr()) {
    ExtTelemetry.sendTelemetryErrorEvent(TelemetryEvent.PreviewAadManifestFile, selectedEnv.error);
    return err(selectedEnv.error);
  }
  const envName = selectedEnv.value;

  const func: Func = {
    namespace: "fx-solution-azure",
    method: "buildAadManifest",
    params: {
      type: "",
    },
  };

  ExtTelemetry.sendTelemetryEvent(
    TelemetryEvent.BuildAadManifestStart,
    getTriggerFromProperty(args)
  );
  const res = await runUserTask(func, TelemetryEvent.BuildAadManifest, false, envName);

  if (res.isErr()) {
    ExtTelemetry.sendTelemetryErrorEvent(TelemetryEvent.PreviewAadManifestFile, res.error);
    return err(res.error);
  }
  const manifestFile = `${workspacePath}/${BuildFolderName}/${AppPackageFolderName}/aad.${envName}.json`;

  if (fs.existsSync(manifestFile)) {
    workspace.openTextDocument(manifestFile).then((document) => {
      window.showTextDocument(document);
    });
    ExtTelemetry.sendTelemetryEvent(TelemetryEvent.PreviewAadManifestFile, {
      [TelemetryProperty.Success]: TelemetrySuccess.Yes,
    });
    return ok(manifestFile);
  } else {
    const error = new SystemError(
      ExtensionSource,
      "FileNotFound",
      util.format(localize("teamstoolkit.handlers.fileNotFound"), manifestFile)
    );
    showError(error);
    ExtTelemetry.sendTelemetryErrorEvent(TelemetryEvent.PreviewAadManifestFile, error);
    return err(error);
  }
}

export async function openPreviewManifest(args: any[]): Promise<Result<any, FxError>> {
  ExtTelemetry.sendTelemetryEvent(TelemetryEvent.PreviewManifestFile, getTriggerFromProperty(args));

  const workspacePath = globalVariables.workspaceUri?.fsPath;
  const validProject = isValidProject(workspacePath);
  if (!validProject) {
    ExtTelemetry.sendTelemetryErrorEvent(
      TelemetryEvent.PreviewManifestFile,
      new InvalidProjectError()
    );
    return err(new InvalidProjectError());
  }

  let isLocalDebug = false;
  let envName = "";
  const selectedEnv = await askTargetEnvironment();
  if (selectedEnv.isErr()) {
    ExtTelemetry.sendTelemetryErrorEvent(TelemetryEvent.PreviewManifestFile, selectedEnv.error);
    return err(selectedEnv.error);
  }
  envName = selectedEnv.value;
  isLocalDebug = envName === "local";

  const res = await buildPackageHandler(isLocalDebug ? ["localDebug"] : ["remote", envName]);
  if (res.isErr()) {
    ExtTelemetry.sendTelemetryErrorEvent(TelemetryEvent.PreviewManifestFile, res.error);
    return err(res.error);
  }
  const manifestFile = `${workspacePath}/${BuildFolderName}/${AppPackageFolderName}/manifest.${
    isLocalDebug ? "local" : envName
  }.json`;

  if (fs.existsSync(manifestFile)) {
    workspace.openTextDocument(manifestFile).then((document) => {
      window.showTextDocument(document);
    });
    ExtTelemetry.sendTelemetryEvent(TelemetryEvent.PreviewManifestFile, {
      [TelemetryProperty.Success]: TelemetrySuccess.Yes,
    });
    return ok(manifestFile);
  } else {
    const error = new SystemError(
      ExtensionSource,
      "FileNotFound",
      util.format(localize("teamstoolkit.handlers.fileNotFound"), manifestFile)
    );
    showError(error);
    ExtTelemetry.sendTelemetryErrorEvent(TelemetryEvent.PreviewManifestFile, error);
    return err(error);
  }
}
export async function openConfigStateFile(args: any[]): Promise<any> {
  let telemetryStartName = TelemetryEvent.OpenManifestConfigStateStart;
  let telemetryName = TelemetryEvent.OpenManifestConfigState;

  if (args && args.length > 0 && args[0].from === "aad") {
    telemetryStartName = TelemetryEvent.OpenAadConfigStateStart;
    telemetryName = TelemetryEvent.OpenAadConfigState;
  }

  ExtTelemetry.sendTelemetryEvent(telemetryStartName);
  const workspacePath = globalVariables.workspaceUri?.fsPath;
  if (!workspacePath) {
    const noOpenWorkspaceError = new UserError(
      ExtensionSource,
      ExtensionErrors.NoWorkspaceError,
      localize("teamstoolkit.handlers.noOpenWorkspace")
    );
    showError(noOpenWorkspaceError);
    ExtTelemetry.sendTelemetryErrorEvent(telemetryName, noOpenWorkspaceError);
    return err(noOpenWorkspaceError);
  }

  if (!isValidProject(workspacePath)) {
    const invalidProjectError = new UserError(
      ExtensionSource,
      ExtensionErrors.InvalidProject,
      localize("teamstoolkit.handlers.invalidProject")
    );
    showError(invalidProjectError);
    ExtTelemetry.sendTelemetryErrorEvent(telemetryName, invalidProjectError);
    return err(invalidProjectError);
  }

  const env: Result<string | undefined, FxError> = await askTargetEnvironment();
  if (env.isErr()) {
    ExtTelemetry.sendTelemetryErrorEvent(telemetryName, env.error);
    return err(env.error);
  }

  let sourcePath: string;
  let isConfig = false;
  if (args && args.length > 0 && args[0].type === "config") {
    isConfig = true;
    sourcePath = path.resolve(
      `${workspacePath}/.${ConfigFolderName}/${InputConfigsFolderName}/`,
      EnvConfigFileNameTemplate.replace(EnvNamePlaceholder, env.value!)
    );
  } else {
    sourcePath = path.resolve(
      `${workspacePath}/.${ConfigFolderName}/${StatesFolderName}/`,
      EnvStateFileNameTemplate.replace(EnvNamePlaceholder, env.value!)
    );
  }

  if (!(await fs.pathExists(sourcePath))) {
    if (isConfig) {
      const noEnvError = new UserError(
        ExtensionSource,
        ExtensionErrors.EnvConfigNotFoundError,
        util.format(localize("teamstoolkit.handlers.findEnvFailed"), env.value)
      );
      showError(noEnvError);
      ExtTelemetry.sendTelemetryErrorEvent(telemetryName, noEnvError);
      return err(noEnvError);
    } else {
      const isLocalEnv = env.value === environmentManager.getLocalEnvName();
      const message = isLocalEnv
        ? util.format(localize("teamstoolkit.handlers.localStateFileNotFound"), env.value)
        : util.format(localize("teamstoolkit.handlers.stateFileNotFound"), env.value);
      const noEnvError = new UserError(
        ExtensionSource,
        ExtensionErrors.EnvStateNotFoundError,
        message
      );
      const provision = {
        title: localize("teamstoolkit.commandsTreeViewProvider.provisionTitleNew"),
        run: async (): Promise<void> => {
          Correlator.run(provisionHandler, [TelemetryTriggerFrom.Other]);
        },
      };
      const localdebug = {
        title: localize("teamstoolkit.handlers.localDebugTitle"),
        run: async (): Promise<void> => {
          Correlator.run(selectAndDebugHandler, [TelemetryTriggerFrom.Other]);
        },
      };

      const errorCode = `${noEnvError.source}.${noEnvError.name}`;
      const notificationMessage = noEnvError.displayMessage ?? noEnvError.message;
      window
        .showErrorMessage(
          `[${errorCode}]: ${notificationMessage}`,
          isLocalEnv ? localdebug : provision
        )
        .then((selection) => {
          if (
            selection?.title ===
              localize("teamstoolkit.commandsTreeViewProvider.provisionTitleNew") ||
            selection?.title === localize("teamstoolkit.handlers.localDebugTitle")
          ) {
            selection.run();
          }
        });
      ExtTelemetry.sendTelemetryErrorEvent(telemetryName, noEnvError);
      return err(noEnvError);
    }
  }

  workspace.openTextDocument(sourcePath).then((document) => {
    window.showTextDocument(document);
  });
  ExtTelemetry.sendTelemetryEvent(telemetryName, {
    [TelemetryProperty.Success]: TelemetrySuccess.Yes,
  });
}

export async function updatePreviewManifest(args: any[]): Promise<any> {
  ExtTelemetry.sendTelemetryEvent(
    TelemetryEvent.UpdatePreviewManifestStart,
    getTriggerFromProperty(args && args.length > 1 ? [args[1]] : undefined)
  );
  let env: string | undefined;
  if (args && args.length > 0) {
    const filePath = args[0].fsPath as string;
    if (!filePath.endsWith("manifest.template.json")) {
      const envReg = /manifest\.(\w+)\.json$/;
      const result = envReg.exec(filePath);
      if (result && result.length >= 2) {
        env = result[1];
      }
    }
  }

  if (env && env !== "local") {
    const inputs = getSystemInputs();
    inputs.env = env;
    await core.activateEnv(inputs);
  }
  const func: Func = {
    namespace: "fx-solution-azure/fx-resource-appstudio",
    method: "updateManifest",
    params: {
      envName: env,
    },
  };

  const result = await runUserTask(func, TelemetryEvent.UpdatePreviewManifest, false, env);

  if (!args || args.length === 0) {
    const workspacePath = globalVariables.workspaceUri?.fsPath;
    const inputs = getSystemInputs();
    inputs.ignoreEnvInfo = true;
    const env = await core.getSelectedEnv(inputs);
    if (env.isErr()) {
      ExtTelemetry.sendTelemetryErrorEvent(TelemetryEvent.UpdatePreviewManifest, env.error);
      return err(env.error);
    }
    const manifestPath = `${workspacePath}/${BuildFolderName}/${AppPackageFolderName}/manifest.${env.value}.json`;
    workspace.openTextDocument(manifestPath).then((document) => {
      window.showTextDocument(document);
    });
  }
  return result;
}

export async function editManifestTemplate(args: any[]) {
  ExtTelemetry.sendTelemetryEvent(
    TelemetryEvent.EditManifestTemplate,
    getTriggerFromProperty(args && args.length > 1 ? [args[1]] : undefined)
  );

  if (args && args.length > 0) {
    const segments = args[0].fsPath.split(".");
    const env = segments[segments.length - 2] === "local" ? "local" : "remote";
    const workspacePath = globalVariables.workspaceUri?.fsPath;
    const manifestPath = `${workspacePath}/${TemplateFolderName}/${AppPackageFolderName}/manifest.template.json`;
    workspace.openTextDocument(manifestPath).then((document) => {
      window.showTextDocument(document);
    });
  }
}

export async function editAadManifestTemplate(args: any[]) {
  ExtTelemetry.sendTelemetryEvent(
    TelemetryEvent.EditAadManifestTemplate,
    getTriggerFromProperty(args && args.length > 1 ? [args[1]] : undefined)
  );
  if (args && args.length > 1) {
    const workspacePath = globalVariables.workspaceUri?.fsPath;
    const manifestPath = `${workspacePath}/${TemplateFolderName}/${AppPackageFolderName}/aad.template.json`;
    workspace.openTextDocument(manifestPath).then((document) => {
      window.showTextDocument(document);
    });
  }
}

export async function signOutAzure(isFromTreeView: boolean) {
  ExtTelemetry.sendTelemetryEvent(TelemetryEvent.SignOutStart, {
    [TelemetryProperty.TriggerFrom]: isFromTreeView
      ? TelemetryTriggerFrom.TreeView
      : TelemetryTriggerFrom.CommandPalette,
    [TelemetryProperty.AccountType]: AccountType.Azure,
  });
  const result = await AzureAccountManager.signout();
  if (result) {
    accountTreeViewProviderInstance.azureAccountNode.setSignedOut();
  }
}

export async function signOutM365(isFromTreeView: boolean) {
  ExtTelemetry.sendTelemetryEvent(TelemetryEvent.SignOutStart, {
    [TelemetryProperty.TriggerFrom]: isFromTreeView
      ? TelemetryTriggerFrom.TreeView
      : TelemetryTriggerFrom.CommandPalette,
    [TelemetryProperty.AccountType]: AccountType.M365,
  });
  const vscodeEnv = detectVsCodeEnv();
  let result = false;
  result = await M365TokenInstance.signout();
  if (result) {
    accountTreeViewProviderInstance.m365AccountNode.setSignedOut();
    envTreeProviderInstance.refreshRemoteEnvWarning();
  }
}

export async function signInAzure() {
  vscode.commands.executeCommand("fx-extension.signinAzure");
}

export async function signInM365() {
  vscode.commands.executeCommand("fx-extension.signinM365");
}

export async function selectSubscription() {
  vscode.commands.executeCommand("fx-extension.specifySubscription");
}

export interface VscQuickPickItem extends QuickPickItem {
  /**
   * Current id of the option item.
   */
  id: string;

  function: () => Promise<void>;
}

export async function migrateTeamsTabAppHandler(): Promise<Result<null, FxError>> {
  ExtTelemetry.sendTelemetryEvent(TelemetryEvent.MigrateTeamsTabAppStart);
  const selection = await VS_CODE_UI.showMessage(
    "warn",
    localize("teamstoolkit.migrateTeamsTabApp.warningMessage"),
    true,
    localize("teamstoolkit.migrateTeamsTabApp.upgrade")
  );
  const userCancelError = new UserError(
    ExtensionSource,
    ExtensionErrors.UserCancel,
    localize("teamstoolkit.common.userCancel")
  );
  if (
    selection.isErr() ||
    selection.value !== localize("teamstoolkit.migrateTeamsTabApp.upgrade")
  ) {
    ExtTelemetry.sendTelemetryErrorEvent(TelemetryEvent.MigrateTeamsTabApp, userCancelError);
    return ok(null);
  }
  const selectFolderConfig: SelectFolderConfig = {
    name: localize("teamstoolkit.migrateTeamsTabApp.selectFolderConfig.name"),
    title: localize("teamstoolkit.migrateTeamsTabApp.selectFolderConfig.title"),
  };
  const selectFolderResult = await VS_CODE_UI.selectFolder(selectFolderConfig);
  if (selectFolderResult.isErr() || selectFolderResult.value.type !== "success") {
    ExtTelemetry.sendTelemetryErrorEvent(TelemetryEvent.MigrateTeamsTabApp, userCancelError);
    return ok(null);
  }
  const tabAppPath = selectFolderResult.value.result as string;

  const progressBar = VS_CODE_UI.createProgressBar(
    localize("teamstoolkit.migrateTeamsTabApp.progressTitle"),
    2
  );
  await progressBar.start();

  const migrationHandler = new TeamsAppMigrationHandler(tabAppPath);
  let result: Result<null, FxError> = ok(null);
  let packageUpdated: Result<boolean, FxError> = ok(true);
  let updateFailedFiles: string[] = [];
  try {
    // Update package.json to use @microsoft/teams-js v2
    await progressBar.next(localize("teamstoolkit.migrateTeamsTabApp.updatingPackageJson"));
    VsCodeLogInstance.info(localize("teamstoolkit.migrateTeamsTabApp.updatingPackageJson"));
    packageUpdated = await migrationHandler.updatePackageJson();
    if (packageUpdated.isErr()) {
      throw packageUpdated.error;
    } else if (!packageUpdated.value) {
      // no change in package.json, show warning.
      const warningMessage = util.format(
        localize("teamstoolkit.migrateTeamsTabApp.updatePackageJsonWarning"),
        path.join(tabAppPath, "package.json")
      );
      VsCodeLogInstance.warning(warningMessage);
      VS_CODE_UI.showMessage("warn", warningMessage, false, "OK");
    } else {
      // Update codes to use @microsoft/teams-js v2
      await progressBar.next(localize("teamstoolkit.migrateTeamsTabApp.updatingCodes"));
      VsCodeLogInstance.info(localize("teamstoolkit.migrateTeamsTabApp.updatingCodes"));
      const failedFiles = await migrationHandler.updateCodes();
      if (failedFiles.isErr()) {
        throw failedFiles.error;
      } else {
        updateFailedFiles = failedFiles.value;
        if (failedFiles.value.length > 0) {
          VsCodeLogInstance.warning(
            util.format(
              localize("teamstoolkit.migrateTeamsTabApp.updateCodesErrorOutput"),
              failedFiles.value.length,
              failedFiles.value.join(", ")
            )
          );
          VS_CODE_UI.showMessage(
            "warn",
            util.format(
              localize("teamstoolkit.migrateTeamsTabApp.updateCodesErrorMessage"),
              failedFiles.value.length,
              failedFiles.value[0]
            ),
            false,
            "OK"
          );
        }
      }
    }
  } catch (error) {
    result = wrapError(error as Error);
  }

  if (result.isErr()) {
    await progressBar.end(false);
    showError(result.error);
    ExtTelemetry.sendTelemetryErrorEvent(TelemetryEvent.MigrateTeamsTabApp, result.error);
  } else {
    await progressBar.end(true);
    if (!packageUpdated.isErr() && packageUpdated.value) {
      VS_CODE_UI.showMessage(
        "info",
        util.format(localize("teamstoolkit.migrateTeamsTabApp.success"), tabAppPath),
        false
      );
    }
    ExtTelemetry.sendTelemetryEvent(TelemetryEvent.MigrateTeamsTabApp, {
      [TelemetryProperty.Success]: TelemetrySuccess.Yes,
      [TelemetryProperty.UpdateFailedFiles]: updateFailedFiles.length.toString(),
    });
  }
  return result;
}

export async function migrateTeamsManifestHandler(): Promise<Result<null, FxError>> {
  ExtTelemetry.sendTelemetryEvent(TelemetryEvent.MigrateTeamsManifestStart);
  const selection = await VS_CODE_UI.showMessage(
    "warn",
    localize("teamstoolkit.migrateTeamsManifest.warningMessage"),
    true,
    localize("teamstoolkit.migrateTeamsManifest.upgrade")
  );
  const userCancelError = new UserError(
    ExtensionSource,
    ExtensionErrors.UserCancel,
    localize("teamstoolkit.common.userCancel")
  );
  if (
    selection.isErr() ||
    selection.value !== localize("teamstoolkit.migrateTeamsManifest.upgrade")
  ) {
    ExtTelemetry.sendTelemetryErrorEvent(TelemetryEvent.MigrateTeamsManifest, userCancelError);
    return ok(null);
  }
  const selectFileConfig: SelectFileConfig = {
    name: localize("teamstoolkit.migrateTeamsManifest.selectFileConfig.name"),
    title: localize("teamstoolkit.migrateTeamsManifest.selectFileConfig.title"),
  };
  const selectFileResult = await VS_CODE_UI.selectFile(selectFileConfig);
  if (selectFileResult.isErr() || selectFileResult.value.type !== "success") {
    ExtTelemetry.sendTelemetryErrorEvent(TelemetryEvent.MigrateTeamsManifest, userCancelError);
    return ok(null);
  }
  const manifestPath = selectFileResult.value.result as string;

  const progressBar = VS_CODE_UI.createProgressBar(
    localize("teamstoolkit.migrateTeamsManifest.progressTitle"),
    1
  );
  await progressBar.start();

  const migrationHandler = new TeamsAppMigrationHandler(manifestPath);
  let result: Result<null, FxError> = ok(null);

  try {
    // Update Teams manifest
    await progressBar.next(localize("teamstoolkit.migrateTeamsManifest.updateManifest"));
    VsCodeLogInstance.info(localize("teamstoolkit.migrateTeamsManifest.updateManifest"));
    result = await migrationHandler.updateManifest();
    if (result.isErr()) {
      throw result.error;
    }
  } catch (error) {
    result = wrapError(error as Error);
  }

  if (result.isErr()) {
    await progressBar.end(false);
    showError(result.error);
    ExtTelemetry.sendTelemetryErrorEvent(TelemetryEvent.MigrateTeamsManifest, result.error);
  } else {
    await progressBar.end(true);
    VS_CODE_UI.showMessage(
      "info",
      util.format(localize("teamstoolkit.migrateTeamsManifest.success"), manifestPath),
      false
    );
    ExtTelemetry.sendTelemetryEvent(TelemetryEvent.MigrateTeamsManifest, {
      [TelemetryProperty.Success]: TelemetrySuccess.Yes,
    });
  }
  return result;
}

export async function openDeploymentTreeview(args?: any[]) {
  ExtTelemetry.sendTelemetryEvent(
    TelemetryEvent.ClickOpenDeploymentTreeview,
    getTriggerFromProperty(args)
  );
  if (globalVariables.isTeamsFxProject) {
    vscode.commands.executeCommand("teamsfx-deployment.focus");
  } else {
    vscode.commands.executeCommand("workbench.view.extension.teamsfx");
  }
}

export async function deployAadAppManifest(args: any[]): Promise<Result<null, FxError>> {
  ExtTelemetry.sendTelemetryEvent(TelemetryEvent.DeployAadManifestStart);
  const inputs = getSystemInputs();
  inputs[AadManifestDeployConstants.INCLUDE_AAD_MANIFEST] = "yes";

  if (args && args.length > 1 && args[1] === "CodeLens") {
    const segments = args[0].fsPath.split(".");
    const env = segments[segments.length - 2];
    inputs.env = env;
  } else {
    const selectedEnv = await askTargetEnvironment();
    if (selectedEnv.isErr()) {
      ExtTelemetry.sendTelemetryErrorEvent(TelemetryEvent.DeployAadManifest, selectedEnv.error);
      return err(selectedEnv.error);
    }
    const envName = selectedEnv.value;
    inputs.env = envName;
  }
  return await runCommand(Stage.deploy, inputs);
}

export async function selectTutorialsHandler(args?: any[]): Promise<Result<unknown, FxError>> {
  ExtTelemetry.sendTelemetryEvent(TelemetryEvent.ViewGuidedTutorials, getTriggerFromProperty(args));
  const config: SingleSelectConfig = {
    name: "tutorialName",
    title: "Tutorials",
    options: [
      {
        id: "sendNotification",
        label: `${localize("teamstoolkit.tutorials.sendNotification.label")}`,
        detail: localize("teamstoolkit.tutorials.sendNotification.detail"),
        data: "https://aka.ms/teamsfx-send-notification",
      },
      {
        id: "commandAndResponse",
        label: `${localize("teamstoolkit.tutorials.commandAndResponse.label")}`,
        detail: localize("teamstoolkit.tutorials.commandAndResponse.detail"),
        data: "https://aka.ms/teamsfx-create-command",
      },
      {
        id: "addSso",
        label: `${localize("teamstoolkit.tutorials.addSso.label")}`,
        detail: localize("teamstoolkit.tutorials.addSso.detail"),
        data: "https://aka.ms/teamsfx-add-sso",
      },
      {
        id: "connectApi",
        label: `${localize("teamstoolkit.tutorials.connectApi.label")}`,
        detail: localize("teamstoolkit.tutorials.connectApi.detail"),
        data: "https://aka.ms/teamsfx-connect-api",
      },
    ],
    returnObject: true,
  };

  if (isExistingTabAppEnabled()) {
    config.options.splice(0, 0, {
      id: "embedWebPages",
      label: `${localize("teamstoolkit.tutorials.embedWebPages.label")}`,
      detail: localize("teamstoolkit.tutorials.embedWebPages.detail"),
      data: "https://aka.ms/teamsfx-embed-existing-web",
    });
  }

  const selectedTutorial = await VS_CODE_UI.selectOption(config);
  if (selectedTutorial.isErr()) {
    return err(selectedTutorial.error);
  } else {
    const tutorial = selectedTutorial.value.result as OptionItem;
    return openTutorialHandler([TelemetryTriggerFrom.Auto, tutorial]);
  }
}

export function openTutorialHandler(args?: any[]): Promise<Result<unknown, FxError>> {
  if (!args || args.length !== 2) {
    // should never happen
    return Promise.resolve(ok(null));
  }
  const tutorial = args[1] as OptionItem;
  ExtTelemetry.sendTelemetryEvent(TelemetryEvent.OpenTutorial, {
    ...getTriggerFromProperty(args),
    [TelemetryProperty.TutorialName]: tutorial.id,
  });
  return VS_CODE_UI.openUrl(tutorial.data as string);
}

export async function openDocumentLinkHandler(args?: any[]): Promise<Result<boolean, FxError>> {
  if (!args || args.length < 1) {
    // should never happen
    return Promise.resolve(ok(false));
  }
  const node = args[0] as TreeViewCommand;
  ExtTelemetry.sendTelemetryEvent(TelemetryEvent.Documentation, {
    [TelemetryProperty.TriggerFrom]: TelemetryTriggerFrom.TreeView,
    [TelemetryProperty.DocumentationName]: node.contextValue!,
  });
  switch (node.contextValue) {
    case "signinM365": {
      await vscode.commands.executeCommand("workbench.action.openWalkthrough", {
        category: "TeamsDevApp.ms-teams-vscode-extension#teamsToolkitGetStarted",
        step: "TeamsDevApp.ms-teams-vscode-extension#teamsToolkitGetStarted#teamsToolkitCreateFreeAccount",
      });
      return Promise.resolve(ok(true));
    }
    case "signinAzure": {
      return VS_CODE_UI.openUrl("https://portal.azure.com/");
    }
    case "fx-extension.create":
    case "fx-extension.openSamples": {
      return VS_CODE_UI.openUrl("https://aka.ms/teamsfx-create-project");
    }
    case "fx-extension.openManifest": {
      return VS_CODE_UI.openUrl("https://aka.ms/teamsfx-edit-manifest");
    }
    case "fx-extension.provision": {
      return VS_CODE_UI.openUrl("https://aka.ms/teamsfx-provision-cloud-resource");
    }
    case "fx-extension.build": {
      return VS_CODE_UI.openUrl("https://aka.ms/teams-store-validation");
    }
    case "fx-extension.deploy": {
      return VS_CODE_UI.openUrl("https://aka.ms/teamsfx-deploy");
    }
    case "fx-extension.publish": {
      return VS_CODE_UI.openUrl("https://aka.ms/teamsfx-publish");
    }
  }
  return Promise.resolve(ok(false));
}

export async function signinM365Callback(args?: any[]): Promise<Result<null, FxError>> {
  let node: M365AccountNode | undefined;
  if (args && args.length > 1) {
    node = args[1] as M365AccountNode;
    if (node && node.status === AccountItemStatus.SignedIn) {
      return ok(null);
    }
  }

  const triggerFrom = getTriggerFromProperty(args);
  ExtTelemetry.sendTelemetryEvent(TelemetryEvent.LoginClick, {
    [TelemetryProperty.AccountType]: AccountType.M365,
    ...triggerFrom,
  });

  const tokenRes = await tools.tokenProvider.m365TokenProvider.getJsonObject({
    scopes: AppStudioScopes,
    showDialog: true,
  });
  const token = tokenRes.isOk() ? tokenRes.value : undefined;
  if (token !== undefined && node) {
    node.setSignedIn((token as any).upn ? (token as any).upn : "");
  }

  await envTreeProviderInstance.refreshRemoteEnvWarning();
  return ok(null);
}

export async function refreshSideloadingCallback(args?: any[]): Promise<Result<null, FxError>> {
  const status = await M365TokenInstance.getStatus({ scopes: AppStudioScopes });
  if (status.isOk() && status.value.token !== undefined) {
    accountTreeViewProviderInstance.m365AccountNode.updateSideloading(status.value.token);
  }

  return ok(null);
}

export async function checkSideloadingCallback(args?: any[]): Promise<Result<null, FxError>> {
  VS_CODE_UI.showMessage(
    "error",
    localize("teamstoolkit.accountTree.sideloadingMessage"),
    false,
    localize("teamstoolkit.accountTree.sideloadingJoinM365")
  )
    .then(async (result) => {
      if (result.isOk() && result.value === localize("teamstoolkit.common.readMore")) {
        await VS_CODE_UI.openUrl("https://aka.ms/teamsfx-custom-app");
        ExtTelemetry.sendTelemetryEvent(TelemetryEvent.OpenSideloadingReadmore);
      } else if (
        result.isOk() &&
        result.value === localize("teamstoolkit.accountTree.sideloadingJoinM365")
      ) {
        await VS_CODE_UI.openUrl("https://developer.microsoft.com/microsoft-365/dev-program");
        ExtTelemetry.sendTelemetryEvent(TelemetryEvent.OpenSideloadingJoinM365);
      }
    })
    .catch((_error) => {});
  return ok(null);
}

export async function signinAzureCallback(args?: any[]): Promise<Result<null, FxError>> {
  let node: AzureAccountNode | undefined;
  if (args && args.length > 1) {
    node = args[1] as AzureAccountNode;
    if (node && node.status === AccountItemStatus.SignedIn) {
      return ok(null);
    }
  }

  if (AzureAccountManager.getAccountInfo() === undefined) {
    // make sure user has not logged in
    const triggerFrom = getTriggerFromProperty(args);
    ExtTelemetry.sendTelemetryEvent(TelemetryEvent.LoginClick, {
      [TelemetryProperty.AccountType]: AccountType.Azure,
      ...triggerFrom,
    });
  }
  const token = await AzureAccountManager.getAccountCredentialAsync(true);
  if (token && node) {
    const needSelectSubscription = await node.setSignedIn(
      (token as any).username ? (token as any).username : ""
    );
    if (needSelectSubscription) {
      const solutionSettings = await getAzureSolutionSettings();
      if (solutionSettings && "Azure" === solutionSettings.hostType) {
        await selectSubscriptionCallback();
      }
    }
  }
  return ok(null);
}

export async function selectSubscriptionCallback(args?: any[]): Promise<Result<null, FxError>> {
  tools.telemetryReporter?.sendTelemetryEvent(TelemetryEvent.SelectSubscription, {
    [TelemetryProperty.TriggerFrom]: args
      ? TelemetryTriggerFrom.TreeView
      : TelemetryTriggerFrom.Other,
  });
  const askSubRes = await askSubscription(
    tools.tokenProvider.azureAccountProvider,
    VS_CODE_UI,
    undefined
  );
  if (askSubRes.isErr()) return err(askSubRes.error);
  await AzureAccountManager.setSubscription(askSubRes.value.subscriptionId);
  return ok(null);
}
